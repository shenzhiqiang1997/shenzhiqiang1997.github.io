<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="no one">
  <!-- Open Graph Data -->
  <meta property="og:title" content="tiny-spring-aop-学习总结"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="no one&#39;s blog"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://henzhiqiang1997.github.io"/>
  
    <link rel="alternate" href="/atom.xml" title="no one&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>no one's blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">tiny-spring-aop-学习总结</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/shenzhiqiang1997">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:1422537078@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By no one</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-04-18</span>
            <span class="time">11:42:08</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Java/">Java</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Java/">#Java</a> <a class="tag" href="/tags/Spring/">#Spring</a> <a class="tag" href="/tags/AOP/">#AOP</a> <a class="tag" href="/tags/原理/">#原理</a> <a class="tag" href="/tags/设计模式/">#设计模式</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="Spring-AOP实现相关"><a href="#Spring-AOP实现相关" class="headerlink" title="Spring AOP实现相关"></a>Spring AOP实现相关</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Spring AOP实现中最重要的步骤分别为：如何织入、织入匹配、何时织入。</p>
<h2 id="如何织入"><a href="#如何织入" class="headerlink" title="如何织入"></a>如何织入</h2><p>即如何根据被代理对象的元数据来生成相应的代理对象，下面开始讲解如何实现织入的。<br><a id="more"></a></p>
<h3 id="TargetSource"><a href="#TargetSource" class="headerlink" title="TargetSource"></a>TargetSource</h3><p>被代理对象的元数据，包含被代理对象，被代理对象的class以及被代理对象的接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 被代理对象的元数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 被代理对象的class*/</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; targetClass;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 被代理对象的接口*/</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 被代理的对象*/</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 其他方法省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AdvisedSupport"><a href="#AdvisedSupport" class="headerlink" title="AdvisedSupport"></a>AdvisedSupport</h3><p>代理相关的元数据，包含被代理对象的元数据，以及对被代理对象的方法增强时用到的方法拦截器和决定是否对某个方法增强的方法匹配器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代理相关的元数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 被代理对象的元数据*/</span></span><br><span class="line">    <span class="keyword">private</span> TargetSource targetSource;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 对被代理对象增强时用到的方法拦截器*/</span></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 决定是否要对方法增强的方法匹配器*/</span></span><br><span class="line">    <span class="keyword">private</span> MethodMatcher methodMatcher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他方法省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h3><p>方法拦截器接口，这个是aopalliance包中的类，因为Spring AOP中只对方法做AOP以及拦截，所以该拦截器所做的事情其实就是对被代理对象的增强。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 这里需要传入一个方法调用器，方法调用器执行前后加入一些其他增强逻辑。*/</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AopProxy"><a href="#AopProxy" class="headerlink" title="AopProxy"></a>AopProxy</h3><p>获取AOP代理对象的关键入口接口，暴露了获取代理对象的方法，这也是织入的入口处。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 获取代理对象的规范*/</span></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进一步定义了代理相关元数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> AdvisedSupport advised;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ReflectiveMethodInvocation"><a href="#ReflectiveMethodInvocation" class="headerlink" title="ReflectiveMethodInvocation"></a>ReflectiveMethodInvocation</h3><p>基于反射来调用被代理对象的原始方法，相当于method.invoke(target,args)，这里只是对其做了封装，就是基于反射的原方法调用器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] arguments;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这里直接调用被代理对象原方法*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 其他方法省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AopProxy的两种实现"><a href="#AopProxy的两种实现" class="headerlink" title="AopProxy的两种实现"></a>AopProxy的两种实现</h3><h4 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h4><p>基于JDK动态代理的AOP代理生成类，实现了getProxy方法来返回代理对象，自身也实现了InvocationHandler，即由它来决定如何对被代理对象做增强。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">extends</span> <span class="title">AbstractAopProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 这里直接根据代理相关元数据，通过JDK动态代理来生成代理类*/</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), advised.getTargetSource().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如何对被代理对象做增强*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/* 从代理相关元数据中取出方法拦截器*/</span></span><br><span class="line">        MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">        <span class="comment">/* 这里将代理相关元数据中的方法匹配器与被代理对象中的方法匹配*/</span></span><br><span class="line">        <span class="keyword">if</span> (advised.getMethodMatcher() != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; advised.getMethodMatcher().matches(method, advised.getTargetSource().getTarget().getClass())) &#123;</span><br><span class="line">            <span class="comment">/*只有通过匹配才能对方法进行增强</span></span><br><span class="line"><span class="comment">            就是将原方法调用器传入方法拦截器中并执行拦截器</span></span><br><span class="line"><span class="comment">            拦截器会调用原方法并做一些指定的增强*/</span></span><br><span class="line">            <span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> ReflectiveMethodInvocation(advised.getTargetSource().getTarget(),</span><br><span class="line">                    method, args));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果无法匹配则说明该方法不应该被增强就调用原方法*/</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(advised.getTargetSource().getTarget(), args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 其他方法省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CglibAopProxy"><a href="#CglibAopProxy" class="headerlink" title="CglibAopProxy"></a>CglibAopProxy</h3><p>基于cglib的AOP代理生成类，实现了AopProxy的getProxy方法，通过生成被代理对象的子类来创建代理对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cglib2AopProxy</span> <span class="keyword">extends</span> <span class="title">AbstractAopProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Enhancer用来创建子类代理对象 需要设置父类以及增强的回调函数即方法拦截器*/</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(advised.getTargetSource().getTargetClass());</span><br><span class="line">        enhancer.setInterfaces(advised.getTargetSource().getInterfaces());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DynamicAdvisedInterceptor(advised));</span><br><span class="line">        Object enhanced = enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> enhanced;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这个类其实是对MethodInterceptor的代理*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 代理相关元数据*/</span></span><br><span class="line">        <span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line">        <span class="comment">/* 应当对匹配的方法增强的方法拦截器*/</span></span><br><span class="line">        <span class="keyword">private</span> org.aopalliance.intercept.MethodInterceptor delegateMethodInterceptor;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.advised = advised;</span><br><span class="line">            <span class="comment">/* 从代理相关元数据中取出方法拦截器*/</span></span><br><span class="line">            <span class="keyword">this</span>.delegateMethodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">/* 这里就是增强部分 如果被代理对象的方法匹配</span></span><br><span class="line"><span class="comment">            则用指定的方法拦截器调用原方法并进行增强</span></span><br><span class="line"><span class="comment">            否则仍然调用被代理对象的原方法*/</span></span><br><span class="line">            <span class="keyword">if</span> (advised.getMethodMatcher() == <span class="keyword">null</span></span><br><span class="line">                    || advised.getMethodMatcher().matches(method, advised.getTargetSource().getTargetClass())) &#123;</span><br><span class="line">                <span class="keyword">return</span> delegateMethodInterceptor.invoke(<span class="keyword">new</span> CglibMethodInvocation(advised.getTargetSource().getTarget(), method, args, proxy));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CglibMethodInvocation(advised.getTargetSource().getTarget(), method, args, proxy).proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这里相比ReflectiveMethodInvocation多封装了一个MethodProxy*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInvocation</span> <span class="keyword">extends</span> <span class="title">ReflectiveMethodInvocation</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MethodProxy methodProxy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 通过代理方法对象来调用父类的原方法*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.methodProxy.invoke(<span class="keyword">this</span>.target, <span class="keyword">this</span>.arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 其他方法省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="织入实现过程"><a href="#织入实现过程" class="headerlink" title="织入实现过程"></a>织入实现过程</h3><ol>
<li>织入具体是以JdkDynamic/CglibAopProxy的getProxy为入口开始的。</li>
<li>会根据被代理对象的元数据中的Class对象，接口，方法匹配器和方法拦截器来创建代理类。</li>
<li>首先会先设置代理对象的Class对象以及接口。 </li>
<li>紧接着，JDK/Cglib动态代理分别会为代理对象设置的回调方法(invoke/intercept)中去判断每个方法是不是能被方法匹配器匹配。</li>
<li>如果匹配才进一步在回调函数中调用带有原方法调用器(MethodInvocation)的方法拦截器(MethodInterceptor)(这个方法拦截器中带有增强的逻辑，它会在原方法调用器调用被代理对象的原方法前后加入增强逻辑)</li>
<li>如果不匹配则利用原方法调用器直接调用被代理对象的原方法。</li>
<li>为被代理对象相应的方法做增强之后将会把生成的代理对象返回，至此实现了对一个对象的织入。  </li>
</ol>
<h2 id="织入匹配"><a href="#织入匹配" class="headerlink" title="织入匹配"></a>织入匹配</h2><p>并不是所有对象和方法都被增强，织入谁即解决什么样的对象和方法应该被织入增强，下面开始讲解织入匹配的实现过程。</p>
<h3 id="切点相关"><a href="#切点相关" class="headerlink" title="切点相关"></a>切点相关</h3><h4 id="ClassFilter"><a href="#ClassFilter" class="headerlink" title="ClassFilter"></a>ClassFilter</h4><p>类匹配器接口，定义了匹配类的规范。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class targetClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="MethodMatcher"><a href="#MethodMatcher" class="headerlink" title="MethodMatcher"></a>MethodMatcher</h4><p>方法匹配器接口，定义了匹配方法的规范<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h4><p>切点接口，它暴露了获取方法匹配器和类匹配器的入口，即用于匹配是否对某个对象、方法织入的关键接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="AspectJExpressionPointcut"><a href="#AspectJExpressionPointcut" class="headerlink" title="AspectJExpressionPointcut"></a>AspectJExpressionPointcut</h4><p>基于AspectJ表达式的切点类，它实现了Pointcut,ClassFilter和MethodMatcher接口，由其自身提供基于AspectJ表达式对对象和方法的匹配的功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJExpressionPointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span>, <span class="title">ClassFilter</span>, <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* AspectPointcut AspectJ表达式分析器 可以由他来解析AspectJ表达式*/</span></span><br><span class="line">    <span class="keyword">private</span> PointcutParser pointcutParser;</span><br><span class="line">    <span class="comment">/* 字符串AspectJ表达式*/</span></span><br><span class="line">    <span class="keyword">private</span> String expression;</span><br><span class="line">    <span class="comment">/* 由字符串表达式通过分析器来解析为切点表达式*/</span></span><br><span class="line">    <span class="keyword">private</span> PointcutExpression pointcutExpression;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 由自身来提供类匹配和方法匹配功能*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过AspectJ切点表达式来匹配类*/</span></span><br><span class="line">    <span class="comment">/* checkReadyToMatch在解析前构建AspectJ切点表达式*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">        checkReadyToMatch();</span><br><span class="line">        <span class="keyword">return</span> pointcutExpression.couldMatchJoinPointsInType(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过AspectJ切点表达式来匹配方法*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        checkReadyToMatch();</span><br><span class="line">        ShadowMatch shadowMatch = pointcutExpression.matchesMethodExecution(method);</span><br><span class="line">        <span class="keyword">if</span> (shadowMatch.alwaysMatches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shadowMatch.neverMatches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span>其他情况不判断了！见org.springframework.aop.aspectj.RuntimeTestWa*/</span>lker</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 其他方法省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通知器相关"><a href="#通知器相关" class="headerlink" title="通知器相关"></a>通知器相关</h3><h4 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h4><p>通知器接口，暴露了获取Advice(通知/增强)的入口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line">    <span class="function">Advice <span class="title">getAdvice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="PointcutAdvisor"><a href="#PointcutAdvisor" class="headerlink" title="PointcutAdvisor"></a>PointcutAdvisor</h4><p>切点通知器接口，是切点和通知接口的合体，继承了Advisor接口，进一步定义了获取切点(Pointcut)的规范，也就是说可以通过它暴露的方法同时获得通知和切点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PointcutAdvisor</span> <span class="keyword">extends</span> <span class="title">Advisor</span></span>&#123;</span><br><span class="line">   <span class="function">Pointcut <span class="title">getPointcut</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AspectJPointcutAdvisor"><a href="#AspectJPointcutAdvisor" class="headerlink" title="AspectJPointcutAdvisor"></a>AspectJPointcutAdvisor</h3><p>基于AspcetJ的切点通知器，定义了AspectJ切点和具体的Advice(通知/增强)，它是获取具体织入匹配功能的入口。这是一个配套的功能集合，对匹配的对象及方法做指定的增强。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJExpressionPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title">PointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用AspectJ表达式来匹配对象及其方法*/</span></span><br><span class="line">    <span class="keyword">private</span> AspectJExpressionPointcut pointcut = <span class="keyword">new</span> AspectJExpressionPointcut();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 匹配的方法具体的增强*/</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 其他方法省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="织入匹配实现过程"><a href="#织入匹配实现过程" class="headerlink" title="织入匹配实现过程"></a>织入匹配实现过程</h3><p>假设已经通过配置等手段向IOC容器注册了AspectJExpressionPointcutAd对象和其中的增强对象(即MethodInterceptor)。如下<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"timeInterceptor"</span> <span class="keyword">class</span>=<span class="string">"us.codecraft.tinyioc.aop.TimerInterceptor"</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"aspectjAspect"</span> <span class="keyword">class</span>=<span class="string">"us.codecraft.tinyioc.aop.AspectJExpressionPointcutAdvisor"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"advice"</span> <span class="keyword">ref</span>=<span class="string">"timeInterceptor"</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"expression"</span> <span class="keyword">value</span>=<span class="string">"execution(* us.codecraft.tinyioc.*.*(..))"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个时间拦截器，在原方法盗用的前后加入计时增强*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimerInterceptor</span> <span class="title">implements</span> <span class="title">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span>(<span class="params">MethodInvocation invocation</span>) throws Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Invocation of Method "</span> + invocation.getMethod().getName() + <span class="string">" start!"</span>);</span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Invocation of Method "</span> + invocation.getMethod().getName() + <span class="string">" end! takes "</span> + (System.nanoTime() - time)</span><br><span class="line">                + <span class="string">" nanoseconds."</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>从配置中读入expression和advice，将其注入到AspectJExpressionPointcutAdvisor中去。其中对于expression会用其构建AspectJExpressionPointcut对象，而PointcutExpressionPointcut对象会从expression字符串中解析出AspectJExpression。</li>
<li>维护一个PointcutAdvisor集合，对于每个bean，先用ClassFilter判断是否匹配AspectJ表达式中的类。如果匹配则将PointAdvisor中的MethodMatcher和的MethodInterceptor以及bean的元数据来构成代理相关数据交给JdkDynamic/CglibAopProxy来进行进一步的方法匹配和生成代理对象；如果不匹配则不对该bean进行织入。</li>
<li>如果bean的类匹配，在JdkDynamic/CglibAopProxy会对bean的代理对象设置回调函数(invoke/interceptor)，在这个回调函数中会通过代理相关数据中的MethodMatcher对需要代理的对象的每一个方法进行匹配。<br>如果方法匹配了AspectJ表达式则会调用方法拦截器MethodIntercpetor对方法进行增强，否则将利用原方法调用器MethodInvocation来调用原方法。至此完成了对一个bean的织入匹配和织入。</li>
</ol>
<h2 id="何时织入"><a href="#何时织入" class="headerlink" title="何时织入"></a>何时织入</h2><h3 id="何时"><a href="#何时" class="headerlink" title="何时"></a>何时</h3><p>已经能够织入并且能够织入匹配了，最终的目的还是要将以上两步融入到整个IOC容器的生命周期中，让程序实现自动为匹配表达式的bean及其中的方法做织入，生成代理对象并“偷天换日”，将原来的bean换成代理bean并且放回IOC容器中。我们自然会想到在IOC容器的某个时刻我们可以“趁虚而入”玩一把“狸猫换太子”的把戏，完成我们的目标。其实，这个时刻就是在IOC容器中<strong>bean被实例化并完成初始化(属性注入)之后</strong>进行的。</p>
<h3 id="无侵入地扩展IOC容器"><a href="#无侵入地扩展IOC容器" class="headerlink" title="无侵入地扩展IOC容器"></a>无侵入地扩展IOC容器</h3><p>既然已经知道在何时做bean的织入了，那么之后就是如何实现无侵入地扩展IOC容器，让我们能在bean实例化并初始化之后对bean进行织入。</p>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>bean后置处理器接口，暴露了在bean初始化前后的处理方法，这使得可以让实现该接口的类可以在bean初始化前后对bean做一些处理，比如我们这里想要将bean换成代理bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 在bean初始化前做处理的规范*/</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在bean初始化后做处理的规范*/</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="BeanFactoryAware"><a href="#BeanFactoryAware" class="headerlink" title="BeanFactoryAware"></a>BeanFactoryAware</h4><p>暴露beanFactory的接口，使得实现该类的接口可以设置BeanFactory来调用BeanFactory的一些方法，比如这里对bean做处理时需要通过BeanFactory来获取所有AspectJExpressionPointcutAdvisor来对bean做织入匹配和增强。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="核心实现类"><a href="#核心实现类" class="headerlink" title="核心实现类"></a>核心实现类</h3><h4 id="AspectJAwareAdvisorAutoProxyCreator"><a href="#AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="AspectJAwareAdvisorAutoProxyCreator"></a>AspectJAwareAdvisorAutoProxyCreator</h4><p>在IOC生命周期中自动创建代理对象的类，它实现了上述的BeanPostProcessor接口和BeanFactoryAware接口，能够从BeanFactory中获取到AspectJExpressionPointcutAdvisor来匹配哪些bean及方法做织入，并且能够在bean初始化后为匹配的bean生成代理对象，并玩“变换戏法”，把代理对象作为原来的bean的替代对象返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractBeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这里没有在bean初始化之前做处理 直接返回的原bean*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在bean初始化之后生成代理对象并返回到原处去替换原bean*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* AspectJExpressionPointAdvisor和MethodInterceptor自然是不需要做代理的*/</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> AspectJExpressionPointcutAdvisor) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 对于其他的普通bean 才考虑生成代理对象*/</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 从BeanFacotry中取出并遍历所有AspectJExpressionPointcutAdvisor对象 </span></span><br><span class="line"><span class="comment">        * 依次匹配这个bean是否满足类匹配，如果满足才进一步根据产生代理对象</span></span><br><span class="line"><span class="comment">        * 这里根据bean的元数据，以及切点通知器中的通知(即增强)和切点中的方法匹配器来生成代理相关的元数据</span></span><br><span class="line"><span class="comment">        * 生成JdkDynamic/CglibAopProxy 来创建bean的代理对象 最后将其返回来替代原bean</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 这里从BeanFactory的获取所有切点通知器bean */</span>这是BeanFactory为了实现AOP所做的扩展 之后会细谈</span><br><span class="line">        List&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory</span><br><span class="line">                .getBeansForType(AspectJExpressionPointcutAdvisor.class);</span><br><span class="line">        <span class="keyword">for</span> (AspectJExpressionPointcutAdvisor advisor : advisors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (advisor.getPointcut().getClassFilter().matches(bean.getClass())) &#123;</span><br><span class="line">                AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">                advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());</span><br><span class="line">                advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());</span><br><span class="line"></span><br><span class="line">                TargetSource targetSource = <span class="keyword">new</span> TargetSource(bean, bean.getClass(), bean.getClass().getInterfaces());</span><br><span class="line">                advisedSupport.setTargetSource(targetSource);</span><br><span class="line">                <span class="comment">/* 这里根据bean是否实现了接口来选择使用JDK/Cglib动态代理生成代理对象*/</span></span><br><span class="line">                bean = <span class="keyword">new</span> Cglib2AopProxy(advisedSupport).getProxy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 通过实现BeanFactoryAware接口使得可以引用BeanFactory*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = (AbstractBeanFactory) beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对IOC容器进行扩展"><a href="#对IOC容器进行扩展" class="headerlink" title="对IOC容器进行扩展"></a>对IOC容器进行扩展</h3><p>已经有了自动生成代理对象的AspectJAwareAdvisorAutoProxyCreator，接下来就要把这个过程融入到IOC容器的生命周期中，BeanFactory和ApplicationContext必须扩展才能适应这新添加的处理功能。  </p>
<ol>
<li>首先是要保证实现了BeanPostProcessor的bean后置处理器要先于所有普通bean被实例化，并在IOC容器启动时就把这些对象存放到beanFactory维护的一个容器中以便在每个bean实例化后能够立即调用他们来处理bean。<br>这个工作交给BeanFactory并不合适，因为它应该是高内聚的，只提供bean元数据的注册和创建/初始化bean以及提供bean的功能。所以自然就应该由BeanFacotry的代理类ApplicationContext来完成这一工作。<br>这样的话BeanFactory需要提供实例化一种特定类型的所有bean来让ApplicationContext来获取所有实现了BeanPostProcessor接口的bean。<br>另外是要提供一个注册BeanPostProcessor的接口来让Application将获取到的所有bean后置处理器加入到BeanFactory维护的bean后置处理器列表中。  </li>
<li>其次是BeanFactory在为实现了BeanPostProcessor接口的bean注入属性时，还要将BeanFactory注入到这些bean中使得他们能从BeanFactory中获取所有AspectJExpressionPointcutAdvisor（这个过程中可能会装载该类型的bean，注入AspectJ匹配表达式和Advice增强）来对bean进行织入匹配和增强。 </li>
<li>最后就可以在BeanFactory中在bean实例化后，遍历BeanPostProcessor集合在bean初始化之前，bean初始化之后做额外处理，之后再将更改后的bean返回。<br>这里只看IOC容器中为了实现AOP扩展的部分 其他部分有删减<h4 id="BeanFactory做出的扩展"><a href="#BeanFactory做出的扩展" class="headerlink" title="BeanFactory做出的扩展"></a>BeanFactory做出的扩展</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 这里添加了一个BeanPostProcessor列表*/</span></span><br><span class="line">    <span class="comment">/* 用于存放所有在bean初始化前后对bean做处理的后置处理器*/</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; beanPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No bean named "</span> + name + <span class="string">" is defined"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = beanDefinition.getBean();</span><br><span class="line">        <span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bean = doCreateBean(beanDefinition);</span><br><span class="line">            <span class="comment">/* 实例化bean之后将调用这个方法来对bean做处理*/</span></span><br><span class="line">            bean = initializeBean(bean, name);</span><br><span class="line">            beanDefinition.setBean(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(Object bean, String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* 遍历bean后置处理器列表来对bean做初始化前置处理*/</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor beanPostProcessor : beanPostProcessors) &#123;</span><br><span class="line">            bean = beanPostProcessor.postProcessBeforeInitialization(bean, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span>call initialize method*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 遍历bean后置处理器列表来对bean做初始化后置处理*/</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor beanPostProcessor : beanPostProcessors) &#123;</span><br><span class="line">            bean = beanPostProcessor.postProcessAfterInitialization(bean, name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 将处理后的bean返回替换原bean*/</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这个是注册BeanPostProcessor的接口 提供给ApplciationContext来注册*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这里是将BeanFactory中特定类型的bean全部返回*/</span></span><br><span class="line">    <span class="comment">/* 不仅是给ApplciationContext*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getBeansForType</span><span class="params">(Class type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List beans = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.isAssignableFrom(beanDefinitionMap.get(beanDefinitionName).getBeanClass())) &#123;</span><br><span class="line">                beans.add(getBean(beanDefinitionName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="ApplicationContext做出的修改"><a href="#ApplicationContext做出的修改" class="headerlink" title="ApplicationContext做出的修改"></a>ApplicationContext做出的修改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="comment">/* 在加载完bean元数据之后立即向BeanFactory中注册所有BeanPostProcessor对象*/</span></span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line">        onRefresh();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/* 从beanFactory中获取素有BeanPostProcessor并将其注册到BeanFacotry中*/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(AbstractBeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List beanPostProcessors = beanFactory.getBeansForType(BeanPostProcessor.class);</span><br><span class="line">        <span class="keyword">for</span> (Object beanPostProcessor : beanPostProcessors) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor((BeanPostProcessor) beanPostProcessor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="整个Aop实现过程总结"><a href="#整个Aop实现过程总结" class="headerlink" title="整个Aop实现过程总结"></a>整个Aop实现过程总结</h3><p>下面就自顶向下地对整个AOP实现过程进行分析</p>
<ol>
<li>IOC容器启动时会在ApplicationContext加载完bean元数据并向BeanFacotry注册之后会从BeanFactory中获取所有实现了BeanPostProcessor接口的对象（这个过程会实例化这些bean并将BeanFactory对象注入到其属性中）并将其注册到BeanFactory维护的BeanPostProcessor列表中，保证BeanPostProcessor在所有bean装载之前实例化。</li>
<li>之后BeanFactory对于每个第一次获取的bean，在实例化和初始化bean之后，就会遍历自己维护的BeanPostProcessor列表，对bean进行处理，并将处理完的bean返回做后续操作 。下面主要讨论AspectJAwareAdvisorAutoProxyCreator的处理过程。</li>
<li>AutoProxyCreator对象会通过自身引用的BeanFactory去获取所有对象然后针对每个AspectJExpressionPointcutAdvisor对象对bean进行判断之后决定是否要织入。下面主要讨论一个AspectJExpressionPointcutAdvisor对bean的判断与织入过程。</li>
<li>先是从AspectJExpressionPointcutAdvisor对象中取出AspectJExpressionPointcut，再利用其中的ClassFilter对象对bean做类匹配。只有匹配的bean才能进行织入，如果不匹配则返回原bean。接下来对类匹配成功的bean进行讨论。</li>
<li>对于类匹配成功的bean，根据bean来创建被代理对象的元数据，再根据AspectJExpressionPointcut中的Advice（因为Spring AOP只对方法增强，所以这里就是MethodInterceptor）以及MethodMatcher构建代理元数据。</li>
<li>这之后会根据代理元数据对象来创建JdkDynamic/CglibAopProxy对象（这由bean是否实现了接口来决定，如果实现了接口就是JdkDynamicAopProxy；如果没有实现接口则是CglibAopProxy）来获取代理对象。下面对代理对象的创建进行讨论，JDK/Cglib动态代理虽然有差异，但我会用统一的方式来叙述。</li>
<li>首先是设置bean元数据信息（bean的Class对象，实现的接口，类加载器等），随后就是回调函数(JDK动态代理是InvocationHandler的invoke，Cglib动态代理是Cglib包下的MethodInterceptor的intercept)。</li>
<li>在这个回调函数中，会通过代理元数据中的MethodMatcher对每个方法进行方法匹配。如果这个方法匹配，则会在回调函数中调用代理元数据中的Advice即MethodInterceptor对象的invoke来对原方法方法进行增强（会向其中传入原方法调用器MethodInvocation对象（如果是JDK动态代理是ReflectiveMethodInvocation（它会基于反射调用原bean的原方法），如果是Cglib动态代理是CglibMethodInvocation（它会通过方法代理Method来调用原bean的原方法）））。</li>
<li>至此实现了AOP的基本功能。</li>
</ol>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

