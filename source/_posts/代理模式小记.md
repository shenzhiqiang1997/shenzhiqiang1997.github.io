---
title: 代理模式小记
date: 2018-03-08 18:28:01
tags: 
    - 设计模式
    - Java
categories:
    - 设计模式
---
* 代理模式
代理模式中分为**目标对象**和**代理对象**
目标对象和代理对象需实现相同接口
<!-- more -->
用户直接使用代理对象 而代理对象方法中调用目标对象的方法
可以在代理对象的方法中添加其他逻辑
* 静态代理
目标类和代理类实现相同的接口
代理对象中绑定目标对象 在需要代理的方法添加其他逻辑并调用目标对象的方法
    ```java
    interface Subject{
        void doSomething();
    }
    class RealSubject implements Subject{
    
        @Override
        public void doSomething() {
            System.out.println("doSomething...");
        }
    }
    class ProxySubject implements Subject{
        private Subject target;
    
        /*绑定目标对象*/
        public ProxySubject(Subject target){
            this.target=target;
        }
    
        @Override
        public void doSomething() {
            /*之前做一些事情*/
            System.out.println("before");
            /*调用目标对象的方法*/
            target.doSomething();
            /*之后做一些事情*/
            System.out.println("after");
        }
    }
    public class ProxyTest {
        @Test
        public void test(){
            /*创建目标对象*/
            Subject realSubject=new RealSubject();
            /*根据目标对象创建代理对象*/
            Subject proxySubject=new ProxySubject(realSubject);
            /*调用代理对象实现的方法*/
            proxySubject.doSomething();
        }
    }
    ```
* 动态代理
这里是采用JDK动态代理进行讲解
条件是需要知道目标类的接口 从而使得代理类通过JDK动态生成
首先是创建一个代理处理器继承InvocationHandler接口
通过代理处理器的构造函数来绑定目标对象
重写invoke() 添加代理逻辑并通过反射调用目标对象的方法
在使用处通过JDK的Proxy静态方法创建代理类
实际上也是通过JDK让目标类和代理类实现相同接口 并动态生成接口类

    ```java
    interface Subject{
        void doSomething();
    }
    class RealSubject implements Subject{
    
        @Override
        public void doSomething() {
            System.out.println("doSomething...");
        }
    }
    class ProxyHandler implements InvocationHandler{
        private Object target;
    
        /*绑定目标对象*/
        public ProxyHandler(Object target){
            this.target=target;
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            /*之前做一些事情*/
            System.out.println("before");
            /*调用目标对象的方法*/
            Object result=method.invoke(target,args);
            /*之后做一些事情*/
            System.out.println("after");
            
            return  result;
        }
    }
    public class ProxyTest {
        @Test
        public void test(){
            /*创建目标对象*/
            Subject realSubject=new RealSubject();
            /*生成代理处理器*/
            ProxyHandler proxyHandler=new ProxyHandler(realSubject);
            /*根据目标对象和代理处理器生成代理对象*/
            Subject proxySubject= (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(),
                    realSubject.getClass().getInterfaces(),proxyHandler);
            /*调用代理对象实现的方法*/
            proxySubject.doSomething();
        }
    }
    ```