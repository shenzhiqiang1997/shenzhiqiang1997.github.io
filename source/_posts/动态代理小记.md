---
title: 动态代理小记
date: 2018-04-17 00:36:09
tags: 
    - 设计模式
    - Java
categories:
    - 设计模式
---
# 什么是动态代理
动态代理即在运行时生成字节码，产生代理类并将创建代理对象的代理方式。
# 两种方式
## JDK动态代理
JDK动态代理即JDK中提供的用于动态生成代理对象的方法。其运作机制是通过被代理对象的接口来感知并调用被代理的对象的方法，并在被代理对象方法调用的前后加入期望的增强功能。
<!-- more -->
### 特点
JDK动态代理只能对实现了接口的对象进行代理，并且只能代理接口中规定的方法，对于接口中没有的方法无法进行代理。
### 代码实例
```java
// 被代理对象实现的接口
public interface Subject {
    void hello();
}

// 真实主体
public class RealSubject implements Subject{
    public void hello(){
        System.out.println("Hello World.");
    }
}

// 代理处理类 生成能增强被代理对象的代理对象
public class JdkProxyHandler implements InvocationHandler{
    // 被代理对象
    private Object target;

    public JdkProxyHandler(Object target){
        this.target = target;
    }

    public Object getProxy(){
        // 根据被代理对象的类加载器，接口以及具体的增强调用来生成代理对象
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 增强逻辑
        System.out.println("handle before...");
        // 调用被代理对象原方法
        Object result = method.invoke(target,args);
        // 增强逻辑
        System.out.println("handle after...");

        return result;
    }
}


// 测试类
public class JdkProxyHandlerTest {
    @Test
    public void test(){
        // 被代理对象
        Subject realSubject= new RealSubject();

        JdkProxyHandler jdkProxyHandler = new JdkProxyHandler(realSubject);
        // 生成代理对象
        Subject proxySubject = (Subject) jdkProxyHandler.getProxy();
        proxySubject.hello();
    }
}
```
## cglib动态代理
cglib动态代理需要引入第三方包，不是JDK自带的动态代理方式。其运作机制是继承被代理对象的类并覆写其方法并增强来生成代理对象。
### 特点
cglib动态代理可以对没有实现接口的代理对象创建代理类，通过生成代理类的子类的方式来实现代理，也可以明确的得知final类是无法通过cglib动态代理的方式生成代理对象。
### 代码实现
```java
// 真实主体 未实现任何接口
public class RealSubject {
    public void hello(){
        System.out.println("Hello World.");
    }
}

// 代理处理类 生成增强被代理对象的代理对象
public class CglibProxyHandler implements MethodInterceptor {
    // 被代理的对象
    private Object target;
    public CglibProxyHandler(Object target){
        this.target = target;
    }

    public Object getProxy(){
        Enhancer enhancer = new Enhancer();
        // 设置代理对象的父类
        enhancer.setSuperclass(target.getClass());
        // 设置代理对象的方法回调
        enhancer.setCallback(this);
        // 生成代理类
        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        // 增强逻辑
        System.out.println("handle before...");
        // 调用了代理对象的父类的方法 即调用被代理对象的方法
        Object result = methodProxy.invoke(target,args);
        // 增强逻辑
        System.out.println("handle after...");
        return result;
    }
}
```
# Spring AOP 中的动态代理
Spring中的AOP是基于动态代理实现的，而且只对方法做增强。其默认使用JDK动态代理来生成代理类，当被代理类未实现接口时会采用cglib的方式来生成代理类，如果代理类既未实现接口又是final类，那么将无法进行代理，会抛出异常。