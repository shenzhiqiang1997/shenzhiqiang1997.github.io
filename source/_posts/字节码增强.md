---
title: 字节码增强
date: 2018-10-24 00:54:00
tags: 
    - 字节码增强
    - Java
    - AOP
categories:
    - Java
---
# 什么是字节码增强
在运行时对目标类的字节码进行修改，然后将该字节码重新加载到JVM中，来替换原来的类或者生成新的类。
<!-- more -->
# 实现步骤
1. 读取类的字节码
2. 修改类的字节码
3. 加载修改后的字节码  

# 实现代码
这里使用的是Javassist框架  
采用以下方法可以在方法语句前后插入语句，但是因为语句是分别进行编译的，后面增加的语句无法访问到前面的局部变量，所以会抛出异常。
```java
public class Hello {
    public void hello() throws InterruptedException {
        System.out.println("hello");
    }
}

public class JavassistTest {
    public static void main(String[] args) throws Exception{
        // 从默认用户路径下获取class池
        ClassPool pool = ClassPool.getDefault();

        // 读取Hello的编译时class对象
        CtClass ctClass = pool.get("priv.shen.javassist.Hello");

        // 从编译时class中获取到hello方法的编译时方法对象
        CtMethod ctMethod = ctClass.getDeclaredMethod("hello");
        
        // 在方法语句前插入计时语句
        ctMethod.insertBefore("long before = System.currentTimeMillis();\n");
        // 在方法语句后插入计算耗时并输出的语句
        ctMethod.insertAfter("System.out.println(\"cost: \"+(System.currentTimeMillis()-before)+\" ms\");\n");
        

        // 将编译时class加载为运行时class对象，并实例化新的Hello类对象
        Hello hello = (Hello) ctClass.toClass().newInstance();
        // 运行新的hello
        hello.hello();

    }
}
```  
采用以下方法来解决上面提到的在原语句前后添加的语句无法访问局部变量的问题，实现的功能为：
1. 将原方法命名为hello$old
2. 拷贝原方法，命名为hello
3. 拼接方法体，调用hello$old并在前后拼接计时语句
4. 将拼接好的方法体设置为hello的方法体
5. 将hello方法添加到类的class中
6. 最后调用CtClass对象的toClass()将修改后的字节码加载进JVM
```java
public class JavassistTest {
    public static void main(String[] args) throws Exception{
        // 从默认用户路径下获取class池
        ClassPool pool = ClassPool.getDefault();

        // 读取Hello的编译时class对象
        CtClass ctClass = pool.get("priv.shen.javassist.Hello");

        // 从编译时class中获取到hello方法的编译时方法对象
        CtMethod oldCtMethod = ctClass.getDeclaredMethod("hello");
        // 将hello方法重新命名为hello$old 之后将创建新的hello方法来替换它
        oldCtMethod.setName("hello$old");

        // 将hello$old 拷贝出来生成新的hello编译时方法对象
        CtMethod newCtMethod = CtNewMethod.copy(oldCtMethod,"hello",ctClass,null);

        // 初始化StringBuffer用于拼接方法体
        StringBuffer methodBody = new StringBuffer();
        // 拼接开始计时语句
        methodBody.append("{long before = System.currentTimeMillis();\n");
        // 获取方法的范围值类型
        String returnType = oldCtMethod.getReturnType().getName();
        // 将开始拼接对原方法的调用，如果返回值不是void 需要保存原方法执行后的返回值
        if (!"void".equals(returnType))
            methodBody.append(returnType+" result = ");
        // 拼接对原方法的调用，用$$代替原方法的参数
        methodBody.append("hello$old($$);\n");
        // 拼接运行耗时计算语句
        methodBody.append("System.out.println(\"cost: \"+(System.currentTimeMillis()-before)+\" ms\");\n");
        // 如果原方法有返回值则拼接返回结果的语句
        if (!"void".equals(returnType))
            methodBody.append("return result;\n");
        // 拼接最后的方法的花括号 完成对方法体的拼接
        methodBody.append("}");

        // 将拼接好的方法语句设置为新hello的方法体
        newCtMethod.setBody(methodBody.toString());
        // 将新的hello添加到class中
        ctClass.addMethod(newCtMethod);

        // 将编译时class加载为运行时class对象，并实例化新的Hello类对象
        Hello hello = (Hello) ctClass.toClass().newInstance();
        // 运行新的hello
        hello.hello();

    }
}
```  

# 与AOP对比
1. AOP基于反射调用原方法，而字节码增强是对原方法进行直接调用。从性能上来说，字节码增强更好。  
将上面程序的耗时和AOP实现耗时进行对比，上面的程序只有0到1ms，而AOP却需要10ms到20ms。
2. AOP的切点和切面要在运行前定义好，然后在运行时才产生代理对象。  
而字节码增强，可以在程序运行时，直接操控程序对字节码进行修改和替换，对类进行增强。
3. AOP更多地应用于有预见性的增强，比如日志记录，权限控制这类通用业务的处理。  
而字节码增强更多地应用于非预见性的增强，比如说线上代码的性能检测这类突发的需求。
4. AOP只需定义切面，语义性很强，定义的切面可以复用，更加通用和方便。  
而字节码增强，需要对字节操控和加载，比较繁琐，且针对性比较强，不是那么通用和方便。

