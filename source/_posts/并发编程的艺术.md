---
title: 并发编程的艺术 读书笔记
date: 2018-03-05 00:39:39
tags:
    - 多线程
    - 并发
    - Java
categories:
    - 并发
---
## 并发编程的挑战
* 上下文切换
    1. CPU为多个线程分配时间片，每执行一个时间片后将进行下一个任务，并产生上下文切换（保存山歌任务的状态并加载下个任务的状态），上下文切换会影响多线程的执行速度。
    2. 线程的创建和上下文切换需要额外开销，当并发程序片段执行次数较少时尤为明显。
    3. 线程的Waiting和Runnable状态之间的转换会进行上下文切换。
* 减少上下文切换的方法
    1. 无锁并发编程：多线程竞争锁会导致上下文切换，可以通过避免使用锁来减少上下文切换。例：数据ID%线程数 让不同线程处理一部分数据。
    2. CAS算法：Atomic中的CAS算法更新数据不需要加锁。
    3. 使用最少的线程：在任务很少的时候尽量创建少的线程来避免线程等待带来上下文切换。
    4. 协程：用一个线程调度多个任务。
<!-- more -->
* 避免死锁的方法
    1. 一个锁内最好只占用一个资源。
    2. 一个线程不要同时获取多个锁。
    3. 尽量使锁能够被释放使用。如：使用定时锁、一个数据库连接中完成加锁与解锁。
* 资源限制
    1. 并发要收到硬件和软件资源的限制。
    2. 硬件资源限制一般是CPU处理速度、硬盘读写速度、服务器带宽。
    3. 软件资源限制一般是数据库连接数和Socket连接数。
    4. 如果一段并发程序在资源的限制下串行执行，那么速度会更慢，因为上下文切换和资源调度耗费了更多的时间。
* 解决资源限制
    1. 硬件：考虑使用集群，通过资源ID%机器数来使每台机器处理部分资源。
    2. 软件：考虑使用资源池复用。如：数据库连接池 Socket连接池来限制连接数。
    3. 调整并发度来适应不同的资源情况。
## volatile实现原理
* 可见性
    当一个线程修改共享变量后，其他线程能及时读到被修改的值。
* 被volatie修饰的共享变量在被修改使会发生（底层实现是一个lock指令）：
    1. 修改该共享变量的处理器中的缓存行被写入到内存，并且在缓存一致性下同一时间只能由一个处理器将缓存行写入内存。
    2. 其他处理器由于缓存一致性协议，使得其如果发现缓存行对应内存地址被修改，则该处理器的缓存行无效，在下次访问该共享变量时将从内存中重新读取数据到缓存中。
    3. 该原理使得被volatile修饰的共享变量具有可见性。
##  synchronized实现原理
* synchronized对对象进行加锁 有以下三种形式
    1. 普通同步方法对当前实例对象加锁
    2. 静态同步方法对当前类的Class对象加锁
    3. 同步代码块对括号内对象加锁
* JVM基于进入和退出Monitor对象来实现同步
     monitorenter指令和monitorexit指令在编译时分别插入到同步块开始和同步块结束或者异常发生处，JVM保证每个monitorenter要有对应的monitorexit。每个对象都有一个monitor与之关联，当线程执行到monitorenter指令时将会尝试获取对象对应的monitor来获对象的锁。当线程执行到monitorexit指令时将释放对象对应的monitor来释放对象的锁。
## 锁的优化
* 为了减少加锁和解锁的性能消耗，Java中引入了偏向锁、轻量级锁以及重量级锁。
也就是说现在所一共有四种状态，级别依次升高，分别为无所状态、偏向锁状态、轻量级锁状态以及重量级锁状态。
锁的状态会随着竞争的激烈程度逐渐升级，为了提高获得锁和释放锁的效率，锁升级后不能降级。
* 偏向锁适用于一个线程访问同步块的情况。加锁和解锁不需要额外开销，但当其他线程竞争偏向锁时会引起偏向锁的撤销，偏向锁的撤销带来额外开销。
* 轻量级锁的特点是响应速度快但吞吐量低。线程竞争不会引起阻塞，提高响应速度。线程通过自旋来竞争锁，会消耗CPU。
* 重量级锁的特点是响应速度慢但吞吐量达。线程竞争会引起阻塞，不使用自旋来竞争锁，不会消耗CPU。
## 原子操作的实现原理
* 原子操作指不可被中断的一个或一系列操作。
* 处理器实现原子操作的原理：
    1. 总线锁定
        当一个处理器对共享变量进行修改时，将向总线发出锁信号，封锁其他处理器和内存的通信，阻塞其他处理器的请求。该处理器则可以独占共享内存，但也会导致其他处理器不能操作其他非共享内存，开销较大。
    2. 缓存锁定
        缓存锁定对总线锁定进行优化。当一个处理器对共享变量进行修改时，将把缓存行写入到内存中，并通过缓存一致性协议来阻止由两个以上处理器缓存的内存区域被同时修改来保证操作的原子性。当其他处理器嗅探到缓存行对应的内存被修改后将使对应的缓存行无效，在下次访问共享变量时从内存重新加载数据到缓存行中。
* 当操作的数据不能缓存到处理器或者处理器不支持缓存锁定时，将会用总线锁定来保证原子操作。
## Java实现原子操作的原理
* 在Java中可以通过加锁或者循环CAS来实现原子操作。CAS即CompareAndSwap，比较并交换。
    1. 循环CAS实现原子操作
        * JDK并发包中提供了一些类来支持某个类型共享变量的原子操作。
          例如AtomicInteger、AtomicLong等中有CAS方法来对共享变量进行原子性操作。
        ```java
        import java.util.ArrayList;
        import java.util.concurrent.atomic.AtomicInteger;
        
        public class Counter {
            private int i=0;
            private AtomicInteger atomicI=new AtomicInteger(0);
        
        
            public void count(){
                i++;
            }
        
            public void safeCount(){
                while (true){
                    int i=atomicI.get();
                    boolean success=atomicI.compareAndSet(i,++i);
                    if (success) break;
                }
            }
            public static void main(String[] args) {
                ArrayList<Thread> threads=new ArrayList<>(200);
        
                Counter counter=new Counter();
                for (int i = 0; i <100 ; i++) {
                    Thread thread=new Thread(new Runnable() {
                        @Override
                        public void run() {
                            for (int j = 0; j < 1000; j++) {
                                counter.count();
                                counter.safeCount();
                            }
                        }
                    });
                    threads.add(thread);
                }
        
        
                for (Thread t:
                     threads) {
                    t.start();
                }
        
                //等待所有线程执行结束
                for (Thread t:
                        threads) {
                    try {
                        t.join();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
        
                System.out.println("线程不安全的计数器："+counter.i);
                System.out.println("通过CAS实现线程安全的计数器："+counter.atomicI.get());
        
            }
        
        }
        ```
        * CAS实现原子操作的问题：
            1. ABA问题
                当共享变量的值变化为A->B->A，表面上未发生变化，实际上发生了变化，这是CAS无法检查到的，可以通过添加版本号来解决。
                JDK并发包中用AtomicStampedReference同时对比对象值及其戳（即版本号）来进行CAS操作来解决。
                ```java
                import java.util.concurrent.atomic.AtomicInteger;
                import java.util.concurrent.atomic.AtomicStampedReference;
                
                public class ABA {
                    //无戳的原子Integer 将会发生ABA问题
                    private static AtomicInteger atomicI=new AtomicInteger(1);
                    //有戳的原子Integer 将通过值和戳一起比较解决ABA问题
                    private static AtomicStampedReference<Integer> atomicStampedI
                    =new AtomicStampedReference<>(1,0);
                
                    public static void main(String[] args) throws InterruptedException {
                        
                        Thread t1=new Thread(new Runnable() {
                            @Override
                            public void run() {
                                while (true){
                                    if (atomicI.compareAndSet(1,0)&&
                                    atomicI.compareAndSet(0,1)) break;
                                }
                            }
                        });
                
                        Thread t2=new Thread(new Runnable() {
                            @Override
                            public void run() {
                                while (true){
                                    if(atomicI.compareAndSet(1,0)) break;
                                }
                
                            }
                        });
                
                        t1.start();
                        t2.start();
                
                        t1.join();
                        t2.join();
                        //在发生ABA时 CAS操作会认为值未发生变化 将修改值输出0
                        System.out.println(atomicI.get());
                
                
                        Thread t3=new Thread(new Runnable() {
                            @Override
                            public void run() {
                                while (true){
                                    if (atomicStampedI.compareAndSet
                                    (1,0,atomicStampedI.getStamp(),atomicStampedI.getStamp()+1)
                                    &&
                                    atomicStampedI.compareAndSet
                                    (0,1,atomicStampedI.getStamp(),atomicStampedI.getStamp()+1)) 
                                    break;
                                }
                            }
                        });
                        Thread t4=new Thread(new Runnable() {
                            @Override
                            public void run() {
                                while (true){
                                    if(atomicStampedI.compareAndSet
                                    (1,0,atomicStampedI.getStamp(),atomicStampedI.getStamp()+1)
                                    ) break;
                                }
                            }
                        });
                
                        t3.start();
                        t4.start();
                        //在发生ABA时 由于比对了戳 认为已经发生变化 不修改值 将输出1
                        System.out.println(atomicStampedI.getReference());
                
                    }
                }

                ```
            2. 循环时间长开销大
                如果循环CAS长时间不成功，将会给CPU带来较大的执行开销。通过JVM支持处理器的pause指令来延迟流水线执行指令和避免CPU流水线指令被清空来提高CPU执行效率来解决。
            3. 只能实现单个共享变量的原子操作
                对于多个共享变量操作时，循环CAS无法保证操作的原子性，可以通过使用锁或者把多个共享变量合并为一个共享变量来解决。
                JDK并发包中通过AtomicReference来讲多个变量放入一个对象中进行CAS来解决。
                ```java
                import java.util.ArrayList;
                import java.util.concurrent.atomic.AtomicReference;
                //两个共享变量合成一个共享变量
                class TwoInt{
                    private int i=0;
                    private int j=0;
                
                    public TwoInt increase(){
                        return new TwoInt(i+1,j+2);
                    }
                
                    public TwoInt(){
                
                    }
                
                    public TwoInt(int i,int j){
                        this.i=i;
                        this.j=j;
                    }
                
                    @Override
                    public String toString() {
                        return "i:"+i+","+"j:"+j;
                    }
                }
                public class Counter {
                    //用合成的共享变量来生成原子操作对象
                    private AtomicReference<TwoInt> atomicReference=new AtomicReference<>
                    (new TwoInt());
                
                    //循环CAS实现线程安全计数
                    public void count(){
                        while (true){
                            TwoInt twoInt=atomicReference.get();
                            boolean success=atomicReference.compareAndSet(twoInt,
                            twoInt.increase());
                            if (success) break;
                        }
                    }
                
                    public static void main(String[] args) {
                        ArrayList<Thread> threads=new ArrayList<>(100);
                        Counter counter=new Counter();
                
                        for (int i = 0; i < 100; i++) {
                            Thread thread=new Thread(new Runnable() {
                                @Override
                                public void run() {
                                    for (int j = 0; j <1000 ; j++) {
                                        counter.count();
                                    }
                                }
                            });
                
                            threads.add(thread);
                        }
                
                        for (Thread t:
                                threads) {
                            t.start();
                        }
                
                        //等待所有线程结束
                        for (Thread t:
                             threads) {
                            try {
                                t.join();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                
                        System.out.println(counter.atomicReference.get());
                    }
                }
                ```
    2. 加锁实现原子操作
        * 锁机制保证只有获得锁的线程才能对锁定的内存进行操作
        * 除了偏向锁，JVM在实现其他锁时都是采用的循环CAS来实现锁
        当线程想进入同步块时通过循环CAS来获取锁，当它想退出同步块时通过循环CAS来释放锁
## Java内存模型
#### 并发编程的两个关键性问题
* 线程如何进行
    1. 通信
    即如何交换信息
    2. 同步
    即如何控制操作的相对顺序
* 为了解决这两个问题的并发模型
    1. 共享内存
    线程之间通过共享程序的公共状态 通过对共享内存的读写进行隐式通信
    但必须显式地指定某段代码在线程之间互斥进行 进行显式同步
    2. 消息传递
    线程之间通过发送消息进行显式通信
    线程之间消息的发送与接收按照严格的顺序 进行隐式同步
* Java中采用共享内存作为并发模型
#### Java内存模型的抽象结构
* 堆内存在各线程之间共享 被称为共享内存 存储在共享内存的变量称为共享变量
JMM控制一个线程对共享变量的写入何时被另一个线程可见
共享变量存储在主内存中 而每个线程将共享变量存储在本地内存中
本地内存是JMM的抽象概念 实际上不存在
* JMM通过控制主内存与每个线程的本地内存之间的交换来实现内存可见性
* 线程A与B的通信要经过以下步骤：
    1. 线程A将本地内存A中更新过的共享变量刷新到主内存中
    2. 线程B从主内存中将刷新过的共享变量读取到本地内存B中
#### 从源代码到指令序列的重排序
* 为了提高性能 编译器 处理器会对代码和指令进行重排序
* 从源码到最终执行的指令序列过程
    * 源代码->编译器优化重排序->指令级并行重排序->内存系统重排序->最终指令序列
    1. 编译器优化重排序
    在不改变语义的前提下改变语句顺序
    2. 指令级并行重排序
    为了使指令并行 在无数据依赖的前提下改变机器指令的执行顺序
    3. 内存系统重排序
    改变内存读/写 以及加载顺序
    * 重排序可能导致内存可见性问题
    * 一般JMM通过编译器重排序规则禁止特定类型编译器重排序
    以及通过插入特定的内存屏障来禁止特定类型的处理器重排序
    以此来保证内存的可见性
* happens-before概念
一个操作执行结果对另一个操作可见
则两个操作之间有happens-before关系
* 数据依赖性
如果两个操作访问同一个变量 
且这两个操作中有一个为写操作
则他们有数据依赖性
* as-if-serial 语义
如果遵守as-if-serial语义 那么无论如何重排序
执行结果与串行执行结果一致
#### 从3.2节到3.10节 涉及过深的JMM原理 待补充相关知识后再读
## Java并发编程基础
#### 线程
* 什么是线程
调用一个应用程序是一个进程 一个进程内可以创建多个线程
每个线程有各自的本地内存 可以访问共享的内存变量
处理器将在多个线程之间来回切换
* 一个main方法的运行就包含多个线程
    * JVM信号分发处理线程
    * 调用对象finalize()的线程
    * 清楚Reference的线程
    * main线程
* Java中使用多线程的原因
    1. 将多个线程的任务分配到多个处理器核心 提高效率
    2. 将数据一致性不强的操作派发给多个线程 缩短响应时间
    3. 使我们专注于问题模型建立 然后映射到Java多线程模型
    而不是如何实现多线程化
* 线程优先级
现代操作系统采用时分的方式调度线程 操作系统为线程分配若干时间片
当时间片用完 就发生线程调度 等待下一次分配
    * 优先级就是决定线程分配时间片多少的属性
    * Java中线程的优先级范围为1到10
    默认优先级为5 可以通过setPriority()来修改优先级
    但大多数操作系统会忽略线程优先级的设定或者差异较大
    所以一般多线程程序正确性不依赖于线程优先级的高低
* 线程的状态
Java线程在运行的生命周期可能处于以下6种状态之一
    * NEW(初始状态)
    线程被实例化后进入NEW状态
    * RUNNABLE(运行状态)
    调用start()后进入RUNNABLE状态
    * BLOCKED(阻塞状态)
    等待获得锁时进入BLOCKED状态
    * WAITING(等待状态)
    一直等待直到其他线程通知或者打断后才会解除等待
    一般在调用wait()后进入WAITING状态
    * TIME_WAITING(超时等待状态)
    进入等待 与WAITING相比可以在指定时间后自行解除等待
    * TERMINATED(终止状态)
    线程已经执行完毕后进入TERMINATED状态
* 线程创建之后进入初始状态
调用start()之后进入运行状态
当线程执行wait()之后进入等待状态 该状态的线程需要依靠其他线程通知才能返回到运行状态
而超时状态与等待状态相比在超时时间到达后将会自行返回到运行状态
当线程调用同步块代码时 在没有获得锁的情况下将进入阻塞状态
线程在执行完run()方法内的代码后将进入终止状态
* 注意：Java中将就绪状态和运行状态合称为运行状态
阻塞状态是指进入synchronized状态时等待获取锁的状态
LockSupoort中的park和unpark方法用于等待状态与其他状态切换
因为其是通过LockSupport中的方法来实现的
所以Lock接口中相关方法是在等待状态与其他状态之间的切换
* Daemon线程(守护线程)
    * Daemon线程用于程序后台调度与支持性工作
    可以通过setDaemon(true)来设置一个**尚未启动**的线程为守护线程
    * 当Java虚拟机中**所有非Daemon线程**终止后
    Java虚拟机将退出 此时所有的Daemon线程将立即终止
    那么Daemon线程中的finally块将不会保证被执行
    所以不能依靠Daemon线程的finally块来做关闭或资源清理工作
    跑个程序看看
        ```java
        public class Test {
    
            public static void main(String[] args) {
                Thread daemonThread=new Thread(new DaemonRunner());
                daemonThread.setDaemon(true);
                daemonThread.start();
                //主线程及其相关非守护线程结束之后 JVM退出 
                //导致守护线程立即结束 不会打印输出语句
            }
        
            static class DaemonRunner implements Runnable{
                @Override
                public void run() {
                    //让守护线程休眠 使主线程先结束
                    try{
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        System.out.println("daemon finally code...");
                    }
                }
            }
        }
        ```
#### 启动和终止线程
* 构造线程
一个线程的构建由其父线程进行空间分配和初始化
子线程集成父线程的是否为Daemon、优先级、加载资源的contextLoader
且为子线程分配唯一的ID进行标识
在这之后子线程初始化完毕 在堆内存中等待被运行
* 启动线程
当线程调用start() 将同步告知Java虚拟机
一旦线程规划器有空闲 Java虚拟机将启动该线程
* 线程中断
    * 中断时一个线程的标识位属性
    表示一个线程是否被其他线程中断
    * 中断是线程之间的一种通信方式 当被中断线程发现自身的中断标识位为中断状态
    可以对此进行一系列的响应
    一般用来取消任务或者终止线程
    * 其他线程通过调用一个线程的interrupt()来中断它
    * 线程通过调用isInterrupted()来判断是否被中断
    * 终端标识位的复位
        * 对于抛出InterruptedException的方法被中断时 将抛出异常
    在抛出之前 Java虚拟机会将中断标识位复位后再抛出
    此时用isInterrupted()将返回false
        * 但对于不抛出中断异常的方法被中断时
    其中断标识位不会被复位
    下面跑一个例子看看
        ```java
        public class TestInterrupt {
            public static void main(String[] args) {
        
                Thread sleepThread=new Thread(new SleepRunner());
                //将该线程设置为守护线程 使得所有其他线程退出后 该线程的死循环也能终止
                sleepThread.setDaemon(true);
        
                sleepThread.start();
        
                try {
                    //使主线程休眠1秒 让sleepThread执行一会
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
        
                //对sleepThread中断 因为此时sleepThread在休眠
                // 会抛出InterruptedException异常
                // Java虚拟机在抛出该异常前将中断标识位复位 将会输出false
                sleepThread.interrupt();
        
                Thread busyThread=new Thread(new BusyRunner());
        
                //将该线程设置为守护线程 使得所有其他线程退出后 该线程的死循环也能终止
                busyThread.setDaemon(true);
        
                busyThread.start();
        
                try {
                    //使主线程休眠1秒 让busyThread执行一会
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
        
                //对busyThread进行打断
                busyThread.interrupt();
        
                //查看busyThread的标识位 其被中断过 但不抛出中断异常
                // 中断标志位不会被复位 输出true
                System.out.println("busyThread interrupted:"+busyThread.isInterrupted());
            }
        }
        class BusyRunner implements Runnable{
            //该线程一直执行不抛出中断异常的代码
            @Override
            public void run() {
                while (true){
        
                }
            }
        }
        class SleepRunner implements Runnable{
            //该线程一直执行睡眠操作 被打断后会抛出中断异常
            @Override
            public void run() {
                while (true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        System.out.println("sleepThread interrupted:"+Thread.currentThread().isInterrupted());
                    }
                }
            }
        }
        ```
* 不安全的线程操作
suspend()、resume()、stop()因为不安全而作为过期方法被废弃
    * suspend()
        * 对线程进行暂停操作
        * 在调用后 线程不会释放已占有的资源(例如锁)
        而是占用着资源进入睡眠状态 容易引发死锁问题
    * resume() 
        * 对suspend()暂停的线程进行恢复操作
    * stop()
        * 对线程进行终止操作
        * 用该方法在线程终止时不会保证其占用的资源被释放
        导致程序在不确定状态下工作
    * 因此用等待/通知机制即wait/notify来代替suspend()和resume()
* 安全地终止线程
之前提到了如何安全地暂停和恢复线程
这里可以通过中断或者一个boolean变量(volatile)
来保证占用资源的释放并安全地终止线程
跑个程序看一看
    ```java
    public class SafeStopTest {
        public static void main(String[] args) throws Exception{
            Runner runner=new Runner();
            Thread interruptedStopThread=new Thread(runner,"interruptedStopThread");
            interruptedStopThread.start();
    
            //主线程休眠1秒 让interruptedStopThread执行一会
            Thread.sleep(1000);
    
            //通过中断 安全地终止interruptedStopThread 
            // 将输出停止的消息
            interruptedStopThread.interrupt();
    
            Thread booleanStopThread=new Thread(runner,"booleanStopThread");
            booleanStopThread.start();
    
            //主线程休眠1秒 让interruptedStopThread执行一会
            Thread.sleep(1000);
    
            //通过该变布尔值 停止循环 
            // 安全地终止booleanStopThread 将输出停止的消息
            runner.stop();
        }
    }
    class Runner implements Runnable{
        public volatile boolean runnable=true;
        @Override
        public void run() {
            while (runnable&&!Thread.currentThread().isInterrupted());
    
            System.out.println(Thread.currentThread().getName()+" stop");
        }
        public void stop(){
            runnable=false;
        }
    }
    ```
#### 线程间通信
* 每个线程运行后 有自己的栈空间 
按照既定代码运行直到停止
各线程通过通信相互配合完成工作
* Java支持多个线程共同访问一个对象及其变量
每个线程拥有该变量的拷贝
但一个线程看到的变量不一定是最新的
* volatile关键字
volatile修饰的变量 将告知所有线程 
访问它时 必须从共享内存中读取
修改它时 必须将结果同步刷新回共享内存
这能保障被修饰变量在各个线程间的可见性
但过多地使用volatile 也会降低程序执行效率
* synchronized关键字
    * synchronized的本质是对被synchronized保护的对象的监视器的获取
    同一时刻只有一个线程能获取到被保护对象的监视器
    * 任何对象都拥有自己的监视器
    执行同步方法或者同步代码块的线程需要先获取到被保护对象的监视器
    才能进入相应的方法和代码块
    没有获取到监视器你的线程将会被阻塞在同步方法或者同步块的入口处
    进入同步队列并进入BLOCKED状态
    等待获得锁的线程释放锁后将唤醒阻塞在同步队列中的线程
    使其重新尝试对被保护对象的监视器的获取
* 等待/通知机制
    * 等待/通知机制即
    一个线程A调用了对象O的wait() 进入等待状态
    而另一个线程B调用了对象的notify()/notifyAll()
    线程A接收到通知后从对象O的wait()返回 进而执行后续操作
    即两个线程通过调用对象O的wait()和notfiy()进行通信
    * 调用wait() notify() notifyAll()的细节：
        1. 使用wait() notify()/notifyAll()时需要先对调用对象加锁
        2. 调用wait()后 线程状态由RUNNING变为WAITING
        并将当前线程放置到调用对象的等待队列中
        3. 调用notify()/notifyAll()后
        会将等待队列中的一个/所有线程移动到调用对象的同步队列中
        被移动的线程的状态将从WAITING变为BLOCKED
        但这些线程依然不会从wait()中返回 只有这些线程获取到了调用对象的锁 才能从wait()返回
            * 这样做是讲等待/通知机制依托于同步机制
            保证线程从wait()返回时已经获得了调用对象的锁
            使其能够感知到通知线程对调用对象(保护对象)做出的修改
    * 下面来跑一个典型的等待/通知机制的代码看一看
    ```java
        import java.text.SimpleDateFormat;
        import java.util.Date;
        
        public class WaitNotifyTest {
            private static boolean flag=true;
            private static Object lock=new Object();
            private static SimpleDateFormat sdf=new SimpleDateFormat("HH:mm:ss");
            public static void main(String[] args) throws Exception {
                Thread waitThread=new Thread(new Waiter(),"waiter");
                waitThread.start();
        
                //主线程睡眠1秒钟 使等待线程执行一会
                Thread.sleep(1000);
        
                Thread notifyThread=new Thread(new Notifier(),"notifier");
                notifyThread.start();
        
                //主线程睡眠7秒钟 使提醒线程和等待线程执行一会
                Thread.sleep(7000);
            }
        
            static class Waiter implements Runnable{
        
                @Override
                public void run(){
                    //获取到被保护对象的锁
                    synchronized (lock){
                        //如果等待条件满足 则一直调用对象的wait()
                        // 进入WAITING状态 转移到调用对象等待队列
                        while (flag){
                            try {
                                System.out.println("waiting flag is "+flag+","
                                        +Thread.currentThread().getName()+" is waiting at "+sdf.format(new Date()));
                                lock.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
        
                        //直到提醒线程改变条件 调用对象的notify()/notifyAll()通知在调用对象等待队列中的线程
                        //此时等待线程从调用对象的等待队列转移到调用对象的同步队列 从WAITING状态变为BLOCKED状态
                        //直到提醒线程释放锁 等待线程得到调用对象的锁后从调用对象的wait()方法返回 继续执行后续代码
        
                        System.out.println("waiting flag is "+flag+","
                                +Thread.currentThread().getName()+" is running at "+sdf.format(new Date()));
                    }
                }
            }
            static class Notifier implements Runnable{
        
                @Override
                public void run() {
                    //获取到被保护对象的锁
                    synchronized (lock){
                        //改变等待条件 使等待条件不满足
                        flag=false;
                        System.out.println("waiting flag is "+flag+","
                                +Thread.currentThread().getName()+" change flag at "+sdf.format(new Date()));
                        //通知等待线程 使其从调用对象的等待队列转移到同步队列 从WAITING状态变为BLOCKED状态
                        lock.notify();
        
                        // 通知线程带着锁入眠3秒
                        // 使得等待线程无法获得锁从而无法从调用对象的wait()中返回
                        // 如果通知线程醒来后是等待线程获得锁
                        // 将在改变等待条件3秒后看到等待线程输出其正在运行的消息
                        try {
                            Thread.sleep(3000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
        
                    //如果通知线程醒来后仍然是通知线程获得锁
                    //将在改变等待条件6秒后看到等待线程输出其正在运行的消息
                    synchronized (lock){
                        //继续带着锁入眠3秒
                        try {
                            Thread.sleep(3000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }


    ```
    在这个例子中
    waitThread首先获取到对象的锁 调用对象的wait()
    放弃了锁进入到对象的等待队列 进入等待状态
    之后notifyThread获取到对象的锁 调用对象的notify()
    将waitThread移动到对象的同步队列中 此时waitThread状态变为阻塞状态 直到notifyThread释放锁之后
    waitThread获取到锁并从对象的wait()返回并继续执行后续逻辑
* 等待/通知的经典范式
    * 等待/通知具有经典的范式
    分为两个部分：等待方和通知方
    * 等待方
        * 遵守以下原则
            1. 获取对象的锁
            2. 当条件不满足 一直调用对象的wait() 被通知后仍检查条件
            3. 条件满足后则执行对应的逻辑
        * 伪代码
        ```java
            synchronized(对象){
                while(条件不满足){
                    对象.wait();
                }
    
                对应的后续处理逻辑
            }
        ```
    * 通知方
        * 遵循以下原则
            1. 获取对象的锁
            2. 改变条件
            3. 调用对象的notify()/notfiyAll()
            通知等待在调用对象上的线程
        * 伪代码
        ```java
            synchronized(对象){
                改变条件
                对象.notify()/notifyAll();
            }
        ```
* 管道输入/输出流
    * 管道输入/输出流用于线程之间数据传输
    传输过程中以内存为媒介
    * 管道输入/输出流的分类
        * 字节流 PipedInputStream/OutputStream
        * 字符流 PipedReader/Writer
    * 在使用时 必须先将输入流和输出流通过connect连接起来
    否则将无法完成线程之间的传输 并抛出异常
    * 跑个代码来看一看
    ```java
    import java.io.IOException;
    import java.io.PipedReader;
    import java.io.PipedWriter;
    
    public class PipedStreamTest {
        public static void main(String[] args) throws IOException {
            PipedReader reader=new PipedReader();
            PipedWriter writer=new PipedWriter();
            //将管道输入/输出流连接起来
            reader.connect(writer);
    
            //创建输出线程
            Printer printer=new Printer(reader);
            Thread printThread=new Thread(printer);
            //启动输出线程
            printThread.start();
    
            //从主线程不断输出字符到管道流中
            int receive;
            while ((receive=System.in.read())!=-1){
                writer.write(receive);
            }
    
            //关闭流
            writer.close();
            reader.close();
    
        }
        //输出线程
        static class Printer implements Runnable{
            //管道输入流 从相连接的管道输出流读取信息
            private PipedReader reader;
    
            public Printer(PipedReader reader){
                this.reader=reader;
            }
    
            @Override
            public void run() {
                int receive;
                //不断从管道输入流读出信息并输出
                try {
                    while ((receive=reader.read())!=-1){
                        System.out.print(((char) receive));
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    ```
* Thread.join()
    * 线程A调用thread.join()  表示
    线程A等待thread终止后才从join()返回
    * 对于join(millis)的超时方法 表示
    如果线程thread在给定超时时间内没有终止
    线程A将会从join()中返回
    * join() 涉及了等待/通知机制
    当线程终止时 将调用线程自身的notifyAll()
    通知所有等待在该线程对象上的线程
    来看看notify()源码
    ```java
    //进入synchronized方法 当前线程将会加锁调用的线程对象
    public final synchronized void join() throws InterruptedException{
        //当调用的线程对象还未终止时 当前线程调用 调用的线程对象的wait()
        while(isAlive()){
            wait();
        }
        //调用的线程对象已经终止 当前线程将从join()返回
    }
    ```
    这完全符合之前所说的等待/通知范式
    即加锁、条件循环等待、后续逻辑处理三步
    * 来跑一个用join()实现的线程多米诺终止的例子
    ```java
    public class DominoByJoin {
        public static void main(String[] args) throws InterruptedException {
            //首先等待主线程结束
            Thread previous=Thread.currentThread();
    
            //十个线程 每个线程再依次等待前一个线程
            for (int i = 0; i <10 ; i++) {
                //将前一个线程传入当前线程
                // 以便当前线程能调用前一个线程的join()
                Thread thread=new Thread(new Domino(previous),"thread-"+i);
                //启动当前线程
                thread.start();
                //当前线程会成为下一个线程的前一个线程
                previous=thread;
            }
            
            //使得主线程休眠2秒后再终止
            Thread.sleep(2000);
    
            //主线程将结束 将引起后面的线程多米诺地终止
            System.out.println("thread-main is terminated");
        }
    }
    class Domino implements Runnable{
        //用于存放前一个终止的线程
        private Thread previous;
        public Domino(Thread thread){
            previous=thread;
        }
        @Override
        public void run() {
            //当前线程等待前一个线程终止后自己再终止
            try {
                previous.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //待前一个线程终止后输出自己也终止的信息
            System.out.println(Thread.currentThread().getName()+" is terminated");
        }
    }
    ```
* ThreadLocal的使用
    * ThreadLocal是一个以ThreadLocal对象为键
    任意对象为值的存储结构
    * 这个结构被附带在线程上
    即一个线程可以根据一个ThreadLocal对象查询到
    绑定在这个线程上的一个值 可以认为ThreadLocal为线程变量
    它是属于一个线程的 在各个线程之间独立
    * 可以通过set()设置值
    也可以在当前线程通过get()得到原先设置的值
    * 跑个一段代码看一看
    ```java
    public class ThreadLocalTest {
        private static final ThreadLocal<Integer> threadLocal=new ThreadLocal<>();
    
        public static void main(String[] args) throws InterruptedException {
            //在主线程中将threadLocal中的值设置为1
            threadLocal.set(1);
    
            //创建并启动changThread 其将执行threadLocal.set()来试图改变值
            Thread changeThread=new Thread(new Changer());
            changeThread.start();
    
            //主线程等待changeThread更改过threadLocal后再往后执行
            changeThread.join();
    
            //在主线程中获取到threadLocal中的值
            //由于ThreadLocal存储的值在各线程之间相互独立
            // 每个线程只是存放了副本而已 应该输出1
            System.out.println("threadLocal value in main thread is "+threadLocal.get());
        }
    
        static class Changer implements Runnable{
    
            @Override
            public void run() {
                //在该线程中更改threadLocal中的值为2
                threadLocal.set(2);
    
                //在该线程中获取到threadLocal的值
                //在该线程的threadLocal已经变更成功
                //应该输出2
                System.out.println("threadLocal value in changeThread is "+threadLocal.get());
            }
        }
    }
    ```
* 等待超时模式
    * 如果方法能在给定时间内返回结果 那么结果立即返回即可
    否则 等待到超时后返回默认结果
    * 之前的等待/通知 经典范式无法做到超时等待 需要对其做以下改动：
        1. 假设给定超时时间长度为T
        2. 定义等待持续时间remaining=T
        3. 定义超时时刻为future=now+T
        4. 在条件不满足并且remaining>0时
            * wait(remaining)
            * 在wait(remaining)返回后
            重新计算 remaining=future-now
        5. 在条件满足或者remaining<=0 超时后
        执行后续逻辑并退出
    * 这种模式在等待/通知范式的基础上增加了超时控制
    使得调用方法的线程能够按时返回
    * 伪代码 在一定超时时间内获取结果
    ```java
        //获得调用对象的锁
        public synchronized Object get(long mills) throws InterruptedException{
            //超时时刻
            long furture=System.currentTimeMills()+mills;
            //剩余的超时时间
            long remaining=mills;
            //当条件不满足并且还剩余有超时时间时 等待
            while((result==null)&&remaining>0){
                //在调用对象上等待剩余的超时时间
                wait(remaining);
                //当从等待中返回后重新计算剩余的超时时间
                remaining=future-System.currentTimeMills();
            }
            //直到条件满足或者超时 执行后续逻辑并返回
            //result默认值为null 当超时后返回默认结果 
            //否则正常情况下返回被赋予的结果
            return result;
        } 
    ```
* CountDownLatch(计数栅栏)
它的对象latch是携带一个数字的结构 一个线程可以通过latch.await()进入调用对象的等待队列
也可以通过latch.countDown()来使调用对象携带的数字减1
等到latch携带的数字减到0时 所有等待在latch上的线程将从等待中返回
* 线程应用实例
    * 数据库连接池
    数据库连接池运用了超时等待模式来获取数据库连接
    如果获取到数据库连接则返回数据库连接 
    否则在指定时间内没有获取到连接将返回并返回null
    从而避免用户在获取一个数据库连接时长时间等待的情况
    * 线程池技术
    线程池使用等待/通知机制为固定数量的线程分配任务
    从而实现了重复使用固定数目线程完成任务的功能
    减少了创建和销毁线程的开销 同时能够处理过量任务的情景
    * 基于线程池的Web服务器
    Web服务器接收到请求后将其包装成线程可执行的任务 并交由线程池中的线程处理
    从而实现并发处理客户端请求的功能
## Java中的锁
#### Lock接口
* 锁是用来控制多个线程访问共享资源的方式
一般来说 锁可以防止多个线程同时访问共享资源
* synchronized关键字和Lock接口都可以实现锁的功能
    * synchronized关键字
    synchronized在使用时隐式获取与释放锁
        * 具有便捷性
        * 必须先获取锁再释放锁 将锁的获取与释放固化了
    * Lock接口
    Lock接口在使用时需显式地获取与释放锁
        * 对锁的控制更加灵活 扩展性强
        具有锁获取与释放的可操作性
        * 具有更强大的同步特性
        * Lock的使用方式：
        在finally块中保证最终获取到的锁能被释放
        **不应该在try中获取锁 如果在获取锁时发生异常 
        在抛出异常后将导致无故地释放锁**
        ```java
        Lock lock=new ReentrantLock();
        lock.lock();
        try{
            
        }finally{
            lock.unlock();
        }
        ```
        
        * 相比synchronized Lock独有的特性：
            1. 可以尝试非阻塞地获取锁 tryLock()
            在尝试获取锁后不管是否获取到锁 立刻返回
            2. 在获取锁的过程中可以被中断 lockInterruptibly()
            3. 超时获取锁 tryLock(long time,TimeUnit unit)
            在指定时间内获取锁 超时则返回
        * Lock接口中值得一提的API
        Condition newCondition()：
        在当前线程获得了锁的前提下 通过该方法获取和当前锁绑定的等待通知组件
        该组件用于争夺该锁线程间的等待/通知 通信
#### 队列同步器
* 队列同步器
AbstractQueuedSynchronizer(简称同步器)
是用来构建同步组件的基础框架
它使用一个int成员变量表示同步状态
通过内置FIFO队列来完成资源获取线程的排队
* 同步器的作用
同步器是实现同步组件的关键
同步组件聚合同步器 同步器实现同步组件期望的语义
* 同步器的使用
同步器通过继承来使用 子类继承同步器并实现其抽象方法来管理同步状态
而在这些抽象方法实现过程中免不了对同步状态进行访问与更改
同步器提供了3个方法来保证安全地改变同步状态
    1. getState()
    2. setState(int newState)
    3. compareAndSetState(int expect,int update)
    该方法使用CAS设置同步状态 保证设置的原子性
* 同步器可重写的抽象方法
    * 独占式
        * boolean tryAcquire(int arg)
        独占式获取同步状态
        首先需要查询当前同步状态
        并通过CAS使同步状态从期望值0变更为1
            * 如果变更成功返回true
            表示当前线程获取到了同步状态
            * 如果变更失败返回false
            表示获取同步状态失败
        * boolean tryRelease(int arg)
        独占式释放同步状态
        在独占式下释放同步状态的前提是获取到同步状态
        而独占式下只有一个线程能够获取到同步状态
        那么释放同步状态是隐式安全的 不需要用CAS操作保证
            * 如果同步状态为0则为无故释放 抛出异常
            * 否则直接把同步状态从期望值1变更为0 并返回true
            表示当前线程释放了同步状态
        * boolean isHeldExclusively()
        在独占模式下查看同步状态是否为1 
            * 为1则返回ture 表示被线程占有
            * 否则返回false 表示尚未被线程占有
    * 共享式
        * int tryAcquireShared(int arg)
        共享式获取同步状态
        首先需要查询当前同步状态
        判断当前同步状态减去arg是否小于0
            * 如果小于0则直接返回当前同步状态-arg
            表示获取同步状态失败
            * 否则用CAS将同步状态从当前值变更为当前值-arg
            并返回当前值-arg 表示获取同步状态成功
        * boolean tryReleaseShared(int arg)
        共享式释放同步状态
        不同于独占式的实现 由于可以有多个线程同时释放同步状态 
        为了保证线程安全 需要用循环CAS操作将同步状态变更为当前值+arg
        直到成功来保证当前线程一定能释放同步状态
* 用同步器实现自定义同步组件
    * 同步器的子类一般定义为自定义同步组件的静态内部类
    同步器自身不实现同步接口
    仅定义若干同步状态获取与释放的方法供自定义同步组件使用
    * 同步器可以独占式/共享式地获取同步状态
        * 独占式
        同一时刻只能有一个线程获取到同步状态
        * 共享式
        同一时刻可以有多个线程获取到同步状态
    * 同步器的设计基于模板方法模式
        * 同步器提供模板方法 
        模板方法将会调用同步器实现者重写的方法
        * 同步器提供三类作用的模板方法：
            1. 独占式获取与释放同步状态
            2. 共享式获取与释放同步状态
            3. 查询同步队列中等待线程的情况
    * 用同步器实现自定义同步组件的流程：
        1. 实现者继承同步器且重写指定方法
        2. 将实现好的同步器聚合在自定义同步组件的实现中
        3. 自定义同步组件的实现中调用同步器提供的模板方法
        4. 模板方法调用同步器中实现者重写的方法
    * 自定义同步组件正是通过使用同步器提供的模板方法
    来实现自身的同步语义
    * 用户使用时并不会直接和内部同步器的实现打交道
    而是调用自定义组件提供的方法
    而在自定义组件实现中 只需要调用同步器的模板方法
    所以关键在于实现一个怎样的同步器以及如何实现同步器
#### 队列同步器的实现分析
* 同步队列
    * 同步器依赖内部的同步队列来对同步状态管理
    * 同步队列中的节点保存线程引用、等待标志以及前驱和后继节点
    * 节点是同步队列的基础
    同步器中包含两个节点的引用
        * 尾节点
            * 获取同步状态失败的线程构成的节点将加入同步队列的尾部
        同时该线程被阻塞
            * 这个加入队列尾部的过程必须线程安全
            同步器提供基于CAS的设置尾节点的方法:compareAndSetTail
            只有设置成功后 当前线程构成的节点才与之前的尾节点建立联系 并取代它的位置
        * 首节点
            * 获取同步状态成功的线程构成的节点将被设置为首节点
            * 在设置首节点的过程
            因为设置是由获取同步状态成功的线程完成
            而在独占式下只有一个线程可以获得同步状态
            所以设置首节点的方法不需要用CAS来保证
            只需将获得同步状态线程构成的节点设置为原首节点的后继节点
            并断开原首节点的next即可
* 独占式同步状态获取与释放
    * 通过同步器的模板方法acquire(int arg)/release(int arg)
可以独占式获取/释放同步状态
    * 实现原理
        * 获取同步状态
        获取同步状态失败的线程会被加入到同步队列的尾部
        并在同步队列中自旋获取同步状态 直到其前驱节点为首节点且成功获取到同步状态
        将停止自旋并被设置为首结点
        * 释放同步状态
        调用同步器的tryRelease()来尝试释放同步状态
        然后唤醒首节点的后继节点的线程使其重新尝试获取同步状态
    * 模板方法源码
        * 获取同步状态
        ```java
        //如果调用同步器方法获取同步状态失败
        //调用acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        //将当前线程加入同步队列尾部
        public final void acquire(int arg) {
            if (!tryAcquire(arg) &&
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
        }
        ```
        * 释放同步状态
        ```java
        //如果调用同步器方法释放了同步状态
        //则调用unparkSuccessor来重新设置首节点
        //因为只有一个线程成功获取了同步状态 
        //所以只有它能够释放同步状态 所以一定能释放成功
        public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null && h.waitStatus != 0)
                    unparkSuccessor(h);
                return true;
            }
            return false;
        }
        ```
* 共享式同步状态获取与释放
    * 通过同步器的模板方法acquireShared(int arg)/releaseShared(int arg)
    可以共享式获取/释放同步状态
    * 实现原理与独占式的区别
        * 可以多个线程同时获取到同步状态
        * 在一个线程释放同步状态后 会唤醒后续处于等待状态的节点的线程
        * 由于释放同步状态可以来自多个线程
        会发生多个线程同时想进行CAS操作来变更同步状态
        此时就需要通过循环和CAS来保证同步状态的安全释放
        **注意：因为不能保证一个线程能成功释放同步状态
        必须要循环CAS直到成功释放同步状态为止
        否则将不能重新设置首节点 导致该同步状态永远无法释放**
    * 模板方法源码
        * 获取同步状态
        ```java
        //如果调用同步器方法未能获取同步状态
        //则调用doAcquireShared
        //将当前线程加入同步队列尾部
        public final void acquireShared(int arg) {
            if (tryAcquireShared(arg) < 0)
                doAcquireShared(arg);
        }
        
        ```
        * 释放同步状态
        ```java
        //如果调用同步器方法释放了同步状态
        //才能够调用doReleaseShared()来重新设置首节点
        //否则首节点不重新设置 那么同步状态将得不到释放
        public final boolean releaseShared(int arg) {
            if (tryReleaseShared(arg)) {
                doReleaseShared();
                return true;
            }
            return false;
        }
        ```
* 独占式超时获取同步状态
    * 通过同步器的doAcquiredNanos(int arg,long nanosTimeout)
    可以超时获取同步状态
    * 实现原理
    自旋获取同步状态过程与独占式相似 但处理方式不同
        * 如果获取同步状态失败 将判断是否超时
        超时则返回
        未超时则将重新计算超时间隔 然后使线程等待超时间隔的时长
        **注意：如果这个超时间隔小于1000纳秒 将不会进入等待
        而是进入快速自旋 因为短时间的超时等待不精确
        将使超时获取同步状态从整体上不精确**
* 设计并实现自定义组件流程
    1. 确定访问模式
        * 独占式
        * 共享式
    2. 定义资源数
        * 独占式同步资源数为1
        * 共享式同步资源数为期望的并发线程数
    3. 实现同步器
        * 实现相应的同步器方法
        * 用CAS保证同步状态变更的原子性
    4. 实现自定义组件
        * 将同步器聚合到自定义组件中
        * 调用同步器的模板方法实现期望的同步语义
    5. 测试
* 实现例子
实现一个只允许至多两个线程访问的同步组件TwinsLock
```java
//继承Lock接口 实现锁的语义
public class TwinsLock implements Lock {
    //同步器实例 自定义同步组件通过内部的同步器来实现语义
    //最大资源数为2
    private final Sync sync=new Sync(2);

    //聚合同步器
    static class Sync extends AbstractQueuedSynchronizer{

        public Sync(int maxResourceNum){
            //如果资源数不大于0 抛出异常
            if (maxResourceNum<=0)
                throw new IllegalArgumentException("resource number can't lower than 0");
            //正常情况下设置资源数
            setState(maxResourceNum);
        }
        //实现共享式获取/释放资源

        //尝试获取同步状态
        @Override
        protected int tryAcquireShared(int arg) {


            //查询同步状态
            int currentState=getState();
            //得到新的同步状态
            int newState=currentState-arg;

            //如果新的同步状态小于0 则返回新的同步状态 表示获取同步状态失败
            if(newState<0)
                return newState;

            //否则CAS设置新的同步状态
            if (compareAndSetState(currentState,newState))
                return newState;

            //如果没设置成功返回负值表示没有获取成功
            return -1;

        }

        //尝试释放同步状态
        @Override
        protected boolean tryReleaseShared(int arg) {
            
            //为了防止在多个线程同时释放同步状态 导致部分线程CAS操作失败
            //对于一个释放同步状态的线程采用循环CAS保证其释放最终一定成功
            //如果不循环的话 当有多个线程并发操作state
            //只有一个线程能成功 其他线程将失败 
            //而失败的线程将无法重新设置首节点 导致资源无法释放
            while (true){
                //查询同步状态
                int currentState=getState();
                //得到新的同步状态
                int newState=currentState+arg;

                //用CAS操作来设置新的同步状态
                if (compareAndSetState(currentState,newState))
                    return true;
            }

        }
    }

    @Override
    public void lock() {
        //调用同步器的模板方法
        //将资源数减1
        sync.acquireShared(1);
    }

    @Override
    public void unlock() {
        //调用同步器的模板方法
        //将资源数加1
        sync.releaseShared(1);
    }

    //其他接口方法 用不到 暂时不实现
    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public boolean tryLock() {
        return false;
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return false;
    }

    @Override
    public Condition newCondition() {
        return null;
    }
}

//测试类
public class TestTwinsLock {
    //多个线程争夺锁 至多两个线程获得锁
    Lock lock=new TwinsLock();
    //并发倒计器 让10个线程同时去争夺锁
    CountDownLatch latch=new CountDownLatch(10);
    @Test
    public void test() throws InterruptedException {
        for (int i = 0; i <10 ; i++) {
            Thread thread=new Thread(new Runnable() {
                @Override
                public void run() {
                    //当10个线程全部启动前等待
                    try {
                        latch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    lock.lock();
                    try{
                        System.out.println(Thread.currentThread().getName()+" is running");
                        //输出后带锁入眠一秒
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        lock.unlock();
                    }

                }
            });
            //设置为守护线程 等主线程结束后再结束
            thread.setDaemon(true);
            thread.start();
            //每启动一个线程 并发计数-1
            // 减到0后10个线程将一起争夺锁
            latch.countDown();
        }

        //每隔1秒输出一个空格
        // 在这之前一定会有两个线程获取锁并一起输出信息
        while (true) {
            Thread.sleep(1000);
            System.out.println();
        }
    }
}
```
#### ReentrantLock 重入锁
* 定义
重入即支持一个线程对资源重复加锁
* 特性
    1. 支持重入
    2. 支持获取锁时是公平性还是非公平性的选择
* 与synchronized关键字比较
    * synchronized关键字
    隐式地支持重入 即获取到锁的线程仍能连续获取锁
    * RentrantLock
    在调用lock()时 已经获取到锁的线程可以
    再次调用lock()获取到锁而不被阻塞
* 锁获取的公平性
    * 定义如果在绝对时间内 先进行锁获取的线程一定优先被满足 即锁的获取是顺序的 则锁的获取是公平的 否则是不公平的
    * 方式
    ReentrantLock通过构造函数来设置锁获取的公平性
    * 比较
    一般来说 公平所没有非公平锁的效率高
    但 由于等待越久的线程优先满足 公平锁可以减少"饥饿"发生的概率
* 实现
ReentrantLock也通过聚合自定义同步器来实现锁的获取与释放
    1. 重入
    实现重入需要解决两个问题：
        1. 线程再次获取锁
        锁需要去识别当前线程是否是已经占据锁的线程
        如果是则允许该线程再次获取到锁
            * 实现
            以非公平性获取锁为例 对应的同步状态获取方法nonfairTryAcquire()
                * 原理
                在独占式获取同步状态实现的基础上增加了一下逻辑：
                如果当前线程是已经获取到了锁的线程
                那么将同步状态值增加并返回true 表示获取同步状态成功
                * 源码
                ```java
                final boolean nonfairTryAcquire(int acquires) {
                    final Thread current = Thread.currentThread();
                    int c = getState();
                    //锁尚未被线程占有的情况下 直接尝试CAS设置同步状态
                    //设置成功则返回true 表示成功获取锁
                    if (c == 0) {
                        if (compareAndSetState(0, acquires)) {
                            setExclusiveOwnerThread(current);
                            return true;
                        }
                    }
                    //在锁已被线程占有的情况下 
                    //如果当前线程就是占有锁的线程 直接将同步状态值增加 
                    //并返回true 表示再次获取锁
                    else if (current == getExclusiveOwnerThread()) {
                        int nextc = c + acquires;
                        if (nextc < 0) // overflow
                            throw new Error("Maximum lock count exceeded");
                        setState(nextc);
                        return true;
                    }
                    return false;
                }
                ```
        2. 锁的最终释放
        一个线程多次获取锁 自然也需要多次释放锁
        需要对加锁和解锁进行计数 来控制锁的最终释放
        对于一个重入的线程
        当获取到一次锁 计数加1 当释放一次锁 计数减1
        当计数为0时 表示最终成功释放锁 其他线程能够继续获取锁
            * 实现
            对应的同步状态释放方法tryRelease()
                * 原理
                由于获取到锁的线程再次获取到锁时增加了同步状态值
                那么就需要在释放同步状态时减少同步状态值
                同时 如果所释放了n次
                那么前n-1次tryRelease()必须返回false 
                表示释放锁失败
                直到同步状态值减少到0的时候 将锁的占有线程属性设置为null 并返回true
                表示锁最后释放成功
                * 源码
                ```java
                protected final boolean tryRelease(int releases) {
                    int c = getState() - releases;
                    //如果当前线程不是占有锁的线程 抛出异常
                    if (Thread.currentThread() != getExclusiveOwnerThread())
                        throw new IllegalMonitorStateException();
                    //如果同步状态值没有减少到0则返回false
                    //表示锁还没有被真正释放
                    boolean free = false;
                    //如果同步状态值减少到0 则将占有锁的线程这一属性设置为null
                    //且返回true表示 锁最终被成功释放
                    if (c == 0) {
                        free = true;
                        setExclusiveOwnerThread(null);
                    }
                    setState(c);
                    return free;
                }
                ```
    2. 公平与非公平获取锁的区别
        * 非公平锁
        如果一个锁是非公平的
        那么获取锁的顺序应该符合在释放锁后获取到同步状态的顺序
        在同步队列中就不遵循FIFO规则 而是可以"插队"的
            * 原理
            在锁尚未线程占有的情况下 对于非公平锁来说
            只需要CAS设置同步状态成功 则当前线程就获得了锁
            * 源码
            ```java
            final boolean nonfairTryAcquire(int acquires) {
                final Thread current = Thread.currentThread();
                int c = getState();
                //锁尚未被线程占有的情况下 直接尝试CAS设置同步状态
                //设置成功则返回true 表示成功获取锁
                if (c == 0) {
                    if (compareAndSetState(0, acquires)) {
                        setExclusiveOwnerThread(current);
                        return true;
                    }
                }
                //在锁已被线程占有的情况下 
                //如果当前线程就是占有锁的线程 直接将同步状态值增加 
                //并返回true 表示再次获取锁
                else if (current == getExclusiveOwnerThread()) {
                    int nextc = c + acquires;
                    if (nextc < 0) // overflow
                        throw new Error("Maximum lock count exceeded");
                    setState(nextc);
                    return true;
                }
                return false;
            }
                ```
        * 公平锁
        如果一个锁是公平的
        那么获取锁的顺序应该符合请求的绝对时间顺序
        在同步队列中表现为遵循FIFO原则
            * 原理
            公平锁比非公平锁多了一个判断
            即hasQueuedPredecessors()
            判断当前线程的节点是否有前驱节点
                * 如果有前驱
                说明有其他线程更早请求获取锁
                需要等前驱线程获取并释放锁后才能继续获取锁
                * 如果没有前驱
                说明当前线程前没有更早请求获取锁的线程
                才继续试图CAS设置同步状态来获取锁
            * 源码
            ```java
            protected final boolean tryAcquire(int acquires) {
                final Thread current = Thread.currentThread();
                int c = getState();
                //在锁尚未被线程占有的情况下
                //如果没有前驱节点且CAS操作成功
                //才设置当前线程获取到锁 并返回true
                //否则等待前驱节点获取并释放锁后才继续尝试CAS
                if (c == 0) {
                    if (!hasQueuedPredecessors() &&
                        compareAndSetState(0, acquires)) {
                        setExclusiveOwnerThread(current);
                        return true;
                    }
                }
                else if (current == getExclusiveOwnerThread()) {
                    int nextc = c + acquires;
                    if (nextc < 0)
                        throw new Error("Maximum lock count exceeded");
                    setState(nextc);
                    return true;
                }
                return false;
            }
            ```
        * 从上下文切换的角度来比较
            * 在ReentrantLock中默认的锁获取方式为非公平性 
            原因在于：
            公平锁为了保证先请求获取锁的线程优先被满足
            而**进行了大量的线程切换**
            而非公平锁虽然可能造成线程"饥饿"
            但线程切换极少 保证了更大的吞吐量
            * 公平锁的线程切换多于非公平锁的原因在于：
            **是否允许插队来减少延迟**
                * 对于公平锁来说
                当一个线程释放锁后 将唤醒其后的线程
                被唤醒的线程将检查自己是否有前驱
                再尝试进行CAS设置同步状态
                如果有线程正好发起获取锁的请求
                将会被加入到同步队列的尾部
                严格遵守FIFO 不允许"插队"
                * 对于非公平锁来说
                当一个线程释放锁后 如果有线程正好发起获取锁的请求
                那就可以抢在唤醒等待线程前获取到锁
                即这个线程完成了"插队" 避免等待唤醒线程和线程切换
        * 跑个例子来看看重入锁和非重入锁的差异
        ```java
        public class WaitThreads {
            private SubReentrantLock lock;
        
            //根据传入的公平与否创建重入锁
            public WaitThreads(boolean fair){
                lock=new SubReentrantLock(fair);
            }
        
            public void printWaitThreads(){
                //生成十个线程
                for (int i = 0; i < 10; i++) {
                    Thread thread=new Thread(new Runnable() {
                        //每个线程尝试对重入锁加锁/释放两次 
                        //每次加锁后输出正在等待的线程
                        @Override
                        public void run() {
                            for (int j = 0; j < 2; j++) {
                                lock.lock();
                                //输出当前获取到锁的线程名称和正在等待的线程名名称列表
                                System.out.println("now "+Thread.currentThread().getName()
                                +" holds the lock, waiting threads:"
                                +getQueuedThreadsNames(lock.getQueuedThreads()));
                                lock.unlock();
                                // 由于释放锁后紧接着就再次加锁
                                
                                // 显然对于非公平锁来说
                                // 释放锁的线程在释放后会率先抢在唤醒等待线程和其他线程前获取锁 即发生"插队"现象
                                // 十分大的概率出现一个线程连续两次获取到锁的情况
                                
                                // 但对于公平锁来说 只有通过排队的方式来获取锁 
                                // 所以会按照排队时 同步队列的第一个线程作为下一个获取到锁的线程
                                // 不容易出现一个线程在释放锁后就立马再次获取锁的情况 
                            }
                        }
                    });
        
                    thread.start();
                }
            }
            //用于把获取到的等待线程的名字列表提取出来
            private ArrayList<String> getQueuedThreadsNames(Collection<Thread> waitThreads) {
                ArrayList<String> waitThreadsName=new ArrayList<>(waitThreads.size());
                //将每个线程的名字提取成等待线程名称列表
                for (Thread thread:
                        waitThreads) {
                    waitThreadsName.add(thread.getName());
                }
        
                return waitThreadsName;
            }
        }
        //继承ReentrantLock 主要为了覆写getQueuedThreads来获取等待线程
        class SubReentrantLock extends ReentrantLock{
            public SubReentrantLock(boolean fair){
                super(fair);
            }
            //
            @Override
            protected Collection<Thread> getQueuedThreads() {
                //调用父类的getQueuedThreads 获取到等待线程列表
                Collection<Thread> waitThreads=super.getQueuedThreads();
                ArrayList<Thread> waitThreadsArrayList=new ArrayList<>(waitThreads);
                //用于反转列表 将首节点及其后节点提到最前 
                // 使输出更加符合逻辑 便于对比
                Collections.reverse(waitThreadsArrayList);
                return waitThreadsArrayList;
            }
        }
        
        //测试类 测试公平锁和非公平锁
        public class FairAndUnfairTest {
            private WaitThreads fairWaitThreads=new WaitThreads(true);
            private WaitThreads unfairWaitThreads=new WaitThreads(false);
        
            @Test
            public void testFairLock() throws InterruptedException {
                System.out.println("fair lock's waiting condition:");
                fairWaitThreads.printWaitThreads();
                //当前测试线程休眠10秒钟 让其他线程充分执行
                Thread.currentThread().sleep(10000);
            }
            @Test
            public void testUnfairLock() throws InterruptedException {
                System.out.println("unfair lock's waiting condition:");
                unfairWaitThreads.printWaitThreads();
                //当前测试线程休眠10秒钟 让其他线程充分执行
                Thread.currentThread().sleep(10000);
            }
        }    
        ```
#### 读写锁
* 读写锁
    * 之前所说的RentrantLock是排他锁 
    即在同一时刻 只能有一个线程获取锁并访问资源
    但读写锁允许同一时刻多个线程访问 但在写线程访问时
    所有的读线程和其他写线程被阻塞
    * 读写锁维护两个锁 一个读锁 一个写锁
    读锁和写锁是分离的
    能够保证写操作对读操作的可见性和较高的并发性
* 读写操作比较
读写操作的关键在于要使得写操作对其他操作可见 避免脏读
这些读写操作的实现目的也在于此
    * 等待/通知机制
    以前JDK5之前依靠等待/通知机制完成写操作
    即写操作开始时 其他晚于这以操作的线程将进入等待状态
    等写操作完成后 会进行通知等待的线程
    其他线程被唤醒后继续执行相应的操作
    * 读写锁
    读操作的线程获取读锁 写操作的线程获取写锁
    当写锁被获取到时 其他线程将被阻塞 直到写锁被释放
    所有其他线程继续执行
* 特性
    1. 公平性选择
    可以选择获取锁的公平性或非公平性 非公平性的吞吐量仍然更高
    2. 重进入
    读线程获取读锁后可以再次获取读锁
    写线程获取写锁后可以再次获取写锁或者读锁
    3. 锁降级
    写锁能够降级为读锁
* 读写锁的使用
    * Java并发包中的读写锁实现为RentrantReadWriteLock
    该类包含实现ReadWriteLock接口的readLock/writeLock来获取读/写锁
    以及一些用于监视内部工作状态的方法
    * 使用方法：
        1. 调用readLock()/writeLock()获取读/写锁
        2. 在进行读操作前加读锁
        3. 在进行写操作前加写锁
    * 实例
    用一个线程不安全的hashMap以及读写锁来实现线程安全的缓存
    ```java
    public class Cache {
        //线程不安全的hashMap 用来存放缓存
        private Map<String,Object> map=new HashMap<>();
        //读写锁
        private ReadWriteLock readWriteLock= new ReentrantReadWriteLock();
        //得到读锁
        private Lock readLock=readWriteLock.readLock();
        //得到写锁
        private Lock writeLock=readWriteLock.writeLock();
        
        //线程安全地取出缓存数据
        public Object get(String key){
            //当前线程加读锁
            readLock.lock();
            try {
                return map.get(key);
            } finally {
                //当前线程释放读锁
                readLock.unlock();
            }
        }
        
        //线程安全地设置缓存数据
        public Object put(String key,Object object){
            //当前线程加写锁
            writeLock.lock();
            try {
                //设置新值 并将旧值返回
                return map.put(key,object);
            } finally {
                //当前线程释放写锁
                writeLock.unlock();
            }
        }
        
        //线程安全地清空所有缓存数据
        public void clear(){
            //当前线程加写锁
            writeLock.lock();
            try {
                //清空map里的缓存
              map.clear();  
            } finally {
                //当前线程释放写锁
                writeLock.unlock();
            }
        }
    }
    ```
* 读写锁的实现分析
读写锁ReentrantReadWriteLock同样依赖于自定义同步器来实现
    * 读写状态设计
    读写状态就是同步器的同步状态
    所以关键就在于如何在同步状态(一个整型变量)上
    维护多个读线程和一个写线程的状态
        * 为了在一个整型变量上维护多种状态 就需要将这个变量**按位切割**来使用
        在读写锁的实现中将同步状态(一个32位的整型变量)分割为两个部分
            1. 高16位表示读状态
            2. 低16位表示写状态
        * 读写锁通过位运算来迅速确定读和写各自的状态
        假设同步状态为S
            * 写状态为S&0x0000FFFF
            当其增加1时 等于S+1
            * 读状态为S>>>16(无符号右移16位)
            档期增加1时 等于S+(1<<16) 即S+0x00010000
        * 根据状态划分后可以得到一个推论：
        如果S不为0 且写状态为0 则读状态大于0 已经有读锁被线程获取
    * 写锁的获取与释放
    写锁是一个可重入的排它锁
        * 获取
            * 实现原理
                * 如果同步状态为0 则尚未有线程获取到读锁或者写锁
                直接尝试CAS设置同步状态(即增加写状态) 如果成功就获取到写锁
                * 如果同步状态不为0 则已经有线程获取到读锁或者写锁
                则进一步查看写状态
                    * 如果写状态为0 则根据之前的推论
                    读状态大于0 说明已经有线程获取到了读锁
                    则当前线程就必须进入等待状态 直到所有读锁释放才能获取
                    这样做的原因是：
                    在读锁存在的情况下 如果直接获取到写锁并进行数据修改
                    那么这些还未释放读锁的线程将无法感知到数据的更新
                    注意：但是如果一旦写锁被获取到后
                    其他线程的读写操作将被阻塞
                    * 如果写状态不为0 则查看该线程是否是已经获取到写锁的线程
                        * 如果是则增加些状态 并成功再次获取写锁
                        * 否则当前线程获取写锁失败
                * 源码
                ```java
                protected final boolean tryAcquire(int acquires) {
                    Thread current = Thread.currentThread();
                    //获取同步状态
                    int c = getState();
                    //获取写状态
                    int w = exclusiveCount(c);
                    //如果同步状态不为0 则说明已经有获取到读或写锁
                    if (c != 0) {
                        //如果写状态为0或者当前线程不是重入线程 获取锁失败 进入等待
                        if (w == 0 || current != getExclusiveOwnerThread())
                            return false;
                        if (w + exclusiveCount(acquires) > MAX_COUNT)
                            throw new Error("Maximum lock count exceeded");
                        // 重入线程增加写状态
                        setState(c + acquires);
                        return true;
                    }
                    //如果同步状态为0 则直接尝试CAS设置同步状态(增加写状态)
                    if (writerShouldBlock() ||
                        !compareAndSetState(c, c + acquires))
                        return false;
                    //设置当前线程占有写锁
                    setExclusiveOwnerThread(current);
                    return true;
                }
                ```
        * 释放
            * 实现原理
            写锁的释放与ReentrantLock释放过程类似
            每次释放减少写状态 当写状态为0时表示最终成功释放写锁
            从而等待的读写线程可以继续操作且之前的写操作对它们可见
            由于写锁是独占锁且写释放是以获取到写锁为前提
            所以在一个释放写锁的线程在释放时是一定会成功的 即隐式安全
            所以不需要用循环和CAS来保证线程安全
            * 源码
            ```java
            protected final boolean tryRelease(int releases) {
                //如果当前线程不持有写锁却无故释放写锁 抛出异常
                if (!isHeldExclusively())
                    throw new IllegalMonitorStateException();
                //减少同步状态直到写状态为0 则成功最终释放写锁
                int nextc = getState() - releases;
                boolean free = exclusiveCount(nextc) == 0;
                if (free)
                    setExclusiveOwnerThread(null);
                //不需要用循环和CAS来保证线程安全
                setState(nextc);
                return free;
            }
            ```
    * 读锁的获取与释放
    读锁是一个支持重入的共享锁 它能够被多个线程同时获取
    当写状态为0时 读锁总是被成功获取
        * 实现原理
            * 获取锁
                * 如果写状态为0 则尝试CAS增加读状态 如果成功则获取读锁
                * 如果写状态不为0 
                    * 若是当前状态获取到了写锁
                    则尝试用CAS增加读状态 如果成功则获取锁
                    * 否则一经有其他线程获取到写锁 当前线程获取读锁失败
                    进入等待状态
                * 源码
                由于JDK5到6为了监视内部工作状态 实现更加复杂 这里只看核心
                ```java
                protected final int tryAcquireShared(int unused) {
                    Thread current = Thread.currentThread();
                    int c = getState();
                    //如果写状态不为0且当前线程不是获取到写锁的线程 则获取读锁失败
                    //进入等待状态
                    if (exclusiveCount(c) != 0 &&
                        getExclusiveOwnerThread() != current)
                        return -1;
                    //如果写状态不为0 
                    //则总是能够通过尝试CAS设置同步状态(读状态) 成功获取到写锁
                    if (compareAndSetState(c, c + (1 << 16) )) {
                        return 1;
                    }
                }
                ```
            * 释放锁
                * 实现原理
                对于读锁的释放 每次减少读状态 即同步状态减少1 << 16
                由于读锁是否释放对读线程没有影响
                所以直到同步状态为0 即写状态也为0时
                将所有读锁随写锁一同释放
                由于可能有多个线程同时释放读锁并尝试CAS来减少读状态
                而同一时刻 只有一个线程能够CAS成功
                所以要用循环CAS来保证每个释放读锁的线程最终能成功释放
                * 源码
                ```java
                protected final boolean tryReleaseShared(int unused) {
                    //非核心部分源码删除
                    
                    //用循环CAS来保证释放锁的线程最终成功释放
                    for (;;) {
                        int c = getState();
                        //减少同步状态直到同步状态为0 则成功释放读锁
                        //因为释放读锁对读线程并没有影响
                        //所以在同步状态减少为0时 即写状态也为0时
                        //将所有读锁同写锁一起释放
                        int nextc = c - ( 1 << 16 );
                        if (compareAndSetState(c, nextc))
                            return nextc == 0;
                    }
                }
                ```
    * 锁降级
    锁降级是指线程在拥有写锁的前提下 先获取到读锁 再释放写锁的过程
        * 锁降级的必要性
        锁降级的必要性在于确保数据的可见性
        当一个线程A释放写锁后
        如果有另一个线程B尝试获取写锁并对数据进行修改
            * 如果线程A在释放写锁前未获取到读锁
            那么它是无法感知到线程B对数据的更新的
            * 如果线程A在释放写锁前获取到了读锁
            那么根据之前提到的写锁获取原理
            线程B将被阻塞直到线程A用完数据且释放读锁后
            线程B才能获取写锁 并对数据进行修改
        * 不支持升级锁的原因
        目的同样是为了保证数据可见性
        如果有多个获取到读锁的线程
        若其中一个线程升级锁从而获取到了写锁并修改了数据
        该更新对于另外其他的之前获取到读锁的线程来说是不可见的
        * 锁降级实例
        ```java
        public class LockDownLevel {
            //共享变量
            private int resource=0;
            //读写锁 用于获取读/写锁
            private ReadWriteLock readWriteLock=new ReentrantReadWriteLock();
            //读锁
            private Lock readLock=readWriteLock.readLock();
            //写锁
            private Lock writeLock=readWriteLock.writeLock();
        
        
            public void readWriteRead(){
                //加读锁
                readLock.lock();
        
                try {
                    //读取共享变量
                    System.out.println(Thread.currentThread().getName()+" is reading the val: "+resource);
                } finally {
                    //释放读锁
                    readLock.unlock();
                }
        
                try {
                    //加写锁
                    writeLock.lock();
                    //修改共享变量
                    resource++;
                    //锁降级
                    readLock.lock();
                    //释放写锁
                    writeLock.unlock();
        
                    //因为其他线程获得写锁要等到所有已获得读锁的线程释放读锁
                    //这样可以保证在释放写锁后保证能够立即对共享变量做一些操作而不阻塞其他读线程
                    //这样也不至于在后续操作中因为无法感知其他获取到写锁的线程对共享变量的更新
                    //而带来的数据不一致
        
                    //继续读取共享变量 可以进行一些其他操作
                    System.out.println(Thread.currentThread().getName()+" is reading the val after changed: "+resource);
        
                } finally {
                    //释放读锁
                    readLock.unlock();
                }
            }
        }
        
        //测试类 用于测试锁降级
        public class LockDownLevelTest {
            @Test
            public void test() throws InterruptedException {
                LockDownLevel lockDownLevel=new LockDownLevel();
                //启动10个线程
                for (int i = 0; i < 10; i++) {
                    Thread thread=new Thread(new Runnable() {
                        @Override
                        public void run() {
                            lockDownLevel.readWriteRead();
                        }
                    });
        
                    thread.start();
                }
        
                //测试线程休眠5秒 使其他线程充分执行
                Thread.currentThread().sleep(5000);
            }
        }
        ```
#### LockSupport工具
Lock提供一组静态方法 用于阻塞或者唤醒线程 它是构建同步组件的基本工具
* JDK6之前
其中定义一组park开头的方法用于阻塞当前线程
unpark(Thread thread)用于唤醒一个被阻塞的线程
* JDK6之后
新增了park(Object blocker)等带有blocker参数的方法
blocker参数用于标识当前线程正在等待的对象简称阻塞对象
可以通过查看当前线程的阻塞对象 用于问题排查和系统监控
#### Condition接口
* 比较
synchronized关键字通过配合被保护对象的一组监视器方法
wait()/notify()等来实现通知/等待模式
Condition接口提供类似的监视器方法与Lock配合
也能够实现通知/等待模式
但两种方式的使用方式和功能特性存在差别

    差别项      | 对象的监视器方法 | Condition接口
    ---|---|---
    前置条件    | 获取对象的锁     | lock.lock()获取锁                                               lock.newCondtion()获取Condition对象
    等待队列个数 | 一个 |多个
    在等待过程中不响应中断 | 不支持 | 支持
    等待到将来某个时刻 | 不支持 | 支持
* Condition的使用
    * 使用方法
        1. 获取到相关联的锁 即通过Lock.lock()获取锁
        2. 必须通过相关联的Lock获取Condition对象
        即通过Lock.newCondtion() 获取Condition对象
        一般该对象作为成员变量来使用
        3. 当前线程调用Condtion对象.await()释放锁并等待
        4. 当前线程调用Condtion对象.signal()
        唤醒等待在该Condtion对象上的一个线程
        该线程在获取锁后才能从await()返回
    * 使用实例
    通过Lock接口和Condition接口来实现一个有界队列
    ```java
    public class BoundedQueue {
        //用数组实现有界队列
        private Object[] elements;
        //用于存放入队/出队时存放元素的下标
        //以及队列中元素的数量
        private int addIndex,removeIndex,count;
    
        //锁对象
        private Lock lock=new ReentrantLock();
    
        //Condition对象 用于建立等待/通知模型
        //full Condition对象 当有界队列满时 线程的入队操作被阻塞
        private Condition full=lock.newCondition();
        //empty Condition对象 当有界队列空时 线程的出队操作被阻塞
        private Condition empty=lock.newCondition();
    
        public BoundedQueue(int size){
            //如果初始化长度不大于0 抛出异常
            if (size<=0)
                throw new IllegalArgumentException("队列的长度必须大于0");
    
            elements=new Object[size];
        }
    
        //入队操作
        public void add(Object element) throws InterruptedException {
            //对数组操作前加锁 保证可见性和排他性
            lock.lock();
            try {
                //当队列已满 当前线程等待直到队列有空位
                //循环判断是否满足条件
                //防止过早/意外通知导致线程操作的不正确
                while (count==elements.length)
                    full.await();
    
                //有空位时 入队
                elements[addIndex++]=element;
    
                //有界队列采用下标循环的形式来充分利用空间
                if (addIndex==elements.length)
                    addIndex=0;
    
                //入队后元素数量加1
                count++;
                //通知正在等待出队操作的一个线程 条件已经改变
                empty.signal();
            } finally {
                //保证锁最终能够释放
                lock.unlock();
            }
        }
    
        //出队操作
        public Object remove() throws InterruptedException {
            //对数组操作前加锁 保证可见性和排他性
            lock.lock();
            try {
                //当队列为空时 当前线程等待直到队列有元素可以出队
                //采用循环防止过早/意外通知导致线程操作不正确
                while (count==0)
                    empty.await();
    
                //出队
                Object element=elements[removeIndex++];
    
                //有界数组通过下标循环来充分利用空间
                if (removeIndex==elements.length)
                    removeIndex=0;
    
                //出队后队列元素减1
                count--;
    
                //通知正在等待入队操作的一个线程 条件已经改变
                full.signal();
    
                //返回出队元素
                return element;
            } finally {
                //保证最终锁能够释放
                lock.unlock();
            }
    
        }
    }
    
    //测试类
    public class TestBoundedQueue {
        //初始化长度为5的队列
        private BoundedQueue queue=new BoundedQueue(5);
        //用于让20个线程一起争夺锁
        private CountDownLatch latch=new CountDownLatch(20);
        @Test
        public void test() throws InterruptedException {
            //10个线程做入队操作
            for (int i = 0; i < 10; i++) {
                int finalI = i;
                Thread thread=new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            latch.await();
                            queue.add(finalI);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
    
                    }
                });
    
                thread.start();
                latch.countDown();
            }
    
            //10个线程做出队操作
            for (int i = 0; i < 10; i++) {
                Thread thread=new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            latch.await();
                            Object element=queue.remove();
                            System.out.println(Thread.currentThread().getName()
                            +" dequeue the element "+element);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                });
    
                thread.start();
                latch.countDown();
            }
    
            //休眠1秒 让另外20个线程能够充分执行
            Thread.currentThread().sleep(1000);
        }
    }
    ```
* Condition实现分析
因为Condition操作需要先获取相关联的锁
所以CondtionObject必须作为同步器AbstractQueuedSynchronizer的内部类
每个Condition对象都包含一个队列(称为等待队列) 是实现等待/通知功能的关键
    * 等待队列
        * 等待队列是一个FIFO队列
        队列由等待在该Condition对象上的线程构成的节点组成
        该节点复用了同步器中同步队列中节点的定义
        它们的类型都为AQS.Node
        * 当一个已经获取了锁的线程调用Condition对象的await()
        将释放锁 构成节点加入等待队列 并进入等待状态
        * 一个Condition对象包含一个等待队列
        Condition对象具有队列首节点和尾节点两个引用
        加入等待队列的新增节点只需要连接到尾节点后并更新尾节点即可
        不需要用CAS保证 因为线程在调用await()前已经获取了相关联的锁
        由锁已经保证了线程安全
        * 在Object监视器模式上 一个对象拥有一个同步队列和一个等待队列
        而Lock的同步器拥有一个同步器和多个等待队列
        原因在于一个Lock对象可以创建多个Condition对象
        每个Condtion对象维护一个等待队列
    * 等待
        * 从队列的角度看await()
        调用后相当于将同步队列中的首节点(获得锁的线程)中的线程
        构成新的节点并将该节点加入到等待队列中
        * 原理
        一个获取了锁的线程调用了await()之后 会将当前线程加入等待队列
        然后释放同步状态 并唤醒同步队列中的后继节点 随后进入等待状态
        * 源码
        ```java
        public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            //当前线程构成节点加入等待队列
            Node node = addConditionWaiter();
            //释放同步状态
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            //此时当前线程构成的节点并不在同步队列中
            //进入等待状态
            while (!isOnSyncQueue(node)) {
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            //当线程被唤醒后 构成的节点已经移动到了同步队列 可以退出循环
            //这之后通过acquireQueued在同步队列中通过自旋尝试获取同步状态
            
            //如果被唤醒后发现被中断而不是signal唤醒 抛出异常
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
        ```
    * 通知
    调用Condition对象的signal()方法 将唤醒等待队列中的首节点中的线程
    在这之前会先将该节点移动到同步队列中
        * 原理
        当已经获取了锁的线程调用Condition对象的signal()后
        会先被检查是否已经获取了锁 随后获取等待队列的首节点
        并将其移动到同步队列 随后唤醒节点中的线程
        这之后被唤醒的线程将尝试获取同步状态
        在获取同步状态后将从await()返回 继续执行后续逻辑
        signalAll()即对等待队列中的每个节点做signal()操作
        将会把等待队列中的每个节点移动到同步队列后唤醒节点中的线程
        * 源码
        ```java
        public final void signal() {
            //首先检查当前线程是否获取了锁
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            //获取等待队列的首节点
            Node first = firstWaiter;
            //该方法最终将调用transferForSignal来唤醒节点中的线程
            if (first != null)
                doSignal(first);
        }
        
        private void doSignal(Node first) {
            do {
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                first.nextWaiter = null;
            } while (!transferForSignal(first) &&
                     (first = firstWaiter) != null);
        }
        
        final boolean transferForSignal(Node node) {
            if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
                return false;
                
            //equ将线程安全地将该节点移动到同步队列中
            Node p = enq(node);
            int ws = p.waitStatus;
            //这之后就会将节点中的线程唤醒
            if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
                LockSupport.unpark(node.thread);
            return true;
        }
        ```
## Java并发框架与容器
#### CourrentHashMap的实现原理与使用
CourrentHashMap是线程安全且高效的HashMap
* 使用CourrentHashMap的原因
在线程并发环境下
HashMap可能导致程序死循环 线程安全的HashTable效率十分低下
    1. hashMap
    HashMap在高并发执行put操作时会引起死循环
    原因是多线程会使HashMap的Entry链表形成环
    导致在获取Entry时产生死循环
    2. hashTable
    HashTable使用synchronized保证线程安全
    导致同一时刻只有一个线程能够访问HashTable 其他线程被阻塞
    即所有访问HashTable的线程需要争夺同一把锁
    3. CourrentHashMap
    CurrentHashMap采用锁分段奇数 将数据分段存储 每一段数据分配一把锁
    当一个线程访问某一段数据时 其他线程仍然可以访问其他段的数据
    即将多个线程分散争夺多把锁
* ConcurrentHashMap的结构
    * 一个ConcurrentHashMap包含一个Segment数组 Segment是一种重入锁
    一个Segment包含一个HashEntry数组 HashEntry用于存储键值对数据
    * 每个Segment守护着HashEntry数组中的元素
    要对其中的一个元素修改 必须先获取对应Segment的锁
    * 层次
    ConcurrentHashMap->Segment数组->HashEntry数组->键值对
* ConcurrentHashMap的初始化
    1. 初始化segments数组
        * 原理
        segments数组的长度为ssize 通过currencyLevel计算得到
        这个长度首先要满足大于等于currencyLevel
        其次为了能够通过位与运算的算列算法定位segments数组的索引
        必须保证长度为2的N次方 这样其减一后可以对散列值作位与运算
        相当于对数组长度-1取模 能够由此定位某个Segment元素
        * 源码
        ```java
            int sshift = 0;
            int ssize = 1;
            //当ssize小于currencyLevel 不断左移ssize
            //最终ssize将成为大于等于currencyLevel的2的N次方值
            while (ssize < currencyLevel) {
                //sshift记录ssize左移的次数
                ++sshift;
                ssize <<= 1;
            }
            //计算定位时散列值中参与散列运算的位数
            int segmentShift = 32 - sshift;
            //掩码 等于segment数组-1
            int segmentMask = ssize - 1;
            //根据容量构建segments数组
            this.segments=Segment.newArray(ssize);
        ```
    2. 初始化segmentShift和segmentMask
        * 原理
        sshift等于ssize向左移位的次数
        segmentShift用于定位时散列值中参与散列运算的位数 等于32-sshift
        因为ConcurrentHashMap的hash()输出的最大值是32位
        segmentMask是散列运算的掩码 等于ssize-1 即segments数组长度-1
        由于ssize为2的N次方 所以掩码的二进制都为1
        在Segment定位时散列算法用掩码来取模散列值进行定位
        segmentShift以及segmentMask在定位Segment的散列算法中使用
        * 源码
        即初始化segments数组中的源码
    3. 初始化每个segment
        * 原理
        initialCapacity是ConcurrentHashMap的初始化容量
        loadFactor是每个segment的负载因子
        需要通过这两个参数来构造每个segment
        c为均分在每个segment上的容量 等于initialCapacity除以ssize
        cap为segment中HashEntry数组的长度
        cap为大于等于c的2的N次方值
        HashEntry的容量为threshold=(int)cap*loadFactor
        * 源码
        ```java
        if (initialCapacity > MAXIMUM_CAPACITY)

            initialCapacity = MAXIMUM_CAPACITY;
        
        //均分下来一个segment中HashEntry的容量
        int c = initialCapacity / ssize;

        if (c * ssize < initialCapacity)

            ++c;

        int cap = 1;
        
        //最后cap为大于等于c的2的N次方值
        while (cap < c)

            cap <<= 1;
        
        //根据HashEntry容量初始化每个Segment
        for (int i = 0; i < this.segments.length; ++i)
            //最终HashEntry容量为(int)cap*loadFactor
            this.segments[i] = new Segment<K,V>(cap, loadFactor);
        ```
    4. 默认参数情况
    默认情况下
    ssize为16 currencyLevel为16 
    segmentShif为28 segmentMask为15
    initialCapacity为16 loadFactor为0.75
    cap为1 threshold为0
    5. 最大值
    currencyLevel最大值为65535 ssize最大值为65536即16位全1
    
* 定位Segment
    * 由于分段锁保护每段数据
    所以在插入和获取时必须先通过散列算法定位Segment
    * ConcurrentHashMap会首先使用Wang/jekins hash的变种算法
    对元素的hashCode进行一次再散列
    进行再散列的目的是为了减少散列冲突
    使元素均匀地分布在不同Segment中提高容器存取效率
    ```java
        private static int hash(int h) {
            h += (h << 15) ^ 0xffffcd7d; 
            h ^= (h >>> 10);
            h += (h << 3); h ^= (h >>> 6);
            h += (h << 2) + (h << 14); 
            return h ^ (h >>> 16);
        }
    ```
    * 再散列后将散列值无符号右移segmentShift次
    将散列值高位与segmentMask作位运算来定位Segment
    这是为了提高高位的影响 减少散列冲突
    ```java
    final Segment<K,V> segmentFor(int hash) {
        return segments[(hash >>> segmentShift) & segmentMask];
    }
    ```
* ConcurrentHashMap的操作
    1. get操作
        * ConcurrentHashMap的get操作十分高效
        先经过一次再散列 再用这个散列值通过散列运算定位Segment
        再通过散列算法定位HashEntry
            ```java
            public V get(Object key) {
               int hash = hash(key.hashCode());
               return segmentFor(hash).get(key, hash);
            }
            ```
        * get操作的高效在于整个get过程不需要加锁
        原因它的get方法中使用的共享变量都是volatile
        可以保证在线程间的可见性 由于get里只有只读操作
        所以只需要保证共享变量的可见性即可
        只是用volatile代替锁的典型场景
        * 定位HashEntry与Segment时都是使用散列值和数组长度-1做位与操作
        但是Segment用的是再散列后的值的高位
        而HashEntry直接使用再散列值
        也就是说元素在Segment数组之间散列开
        但在一个Segment中的HashEntry数组之间没有散列开
            ```java
            //定位Segment所使用的hash算法
            (hash >>> segmentShift) & segmentMask
            //定位HashEntry所使用的hash算法
            int index = hash & (tab.length - 1);
            ```
    2. put操作
        * put操作需要对共享变量进行修改操作 所以必须加锁来保证线程安全
        * put方法首先定位到Segment 然后在Segment中进行插入操作
        插入操作分为两个步骤
            1. 确定HashEntry数组是否需要扩容
                1. 判断是否需要扩容
                插入元素之前会判断HashEntry数组是否超过容量threshold
                如果超过则扩容
                2. 如何扩容
                扩容时 首先创建容量为原来容量两倍的数组
                然后将原数组元素再散列后插入新数组中
            2. 定位添加元素在HashEntry数组中的位置并放入
            * 它比HashMap更合理
            HashMap是先插入再判断是否需要扩容
            p如果扩容后没有元素插入 等于做了一次无用的扩容
        * put是高效的
        在于它每次只对某个Segment中的HashEntry数组扩容
    3. size操作
        * 如果要统计整个ConcurrentHashMap中的元素个数
        就需要统计所有Segment中元素个数之和
        * 虽然每个Segment中的count是volatile变量 保证在相加时是最新值
        但直接将所有count相加会因为无法保证原子性
        使得在累加过程中已经参与过累加的count发生改变
        这会导致最终结果不准确
        * 由于累加过程中已经累加过的count变化的几率较小
        为了高效 ConcurrentHashMap先尝试2次不锁住所有Segment的方法
        统计各个Segment中元素个数的和
        如果统计过程中 某些Segement中count发生了变化
        再对所有Segment加锁统计一次
        由于modCount在put remove clean方法使用后会加1
        就可以通过modCount是否增加来判断
        在不加锁时统计size前后是否有某些Segment中的count生了变化
#### ConcurrentLinkedQueue
* 实现线程安全队列有两种方式
    1. 使用阻塞算法
    使用阻塞算法可以用一把锁(出队和入队使用同一把锁)
    或者使用两把锁(出队和入队使用不同的锁)
    2. 使用非阻塞算法
    使用非阻塞算法可以通过循环CAS的当时实现
* ConcurrentLinkedQueue采用CAS算法来保证线程安全
* ConcurrentLinkedQueue的结构
    ConcurrentLinkedList采用链表结构 有head tail引用
    默认情况下head=tail=null
* 入队
    * 单线程下入队的过程
        1. 将入队节点设置为尾节点的下一个节点
        2. 更新tail引用
    * 多线程下入队
        * 由于多线程下 一个线程在入队操作的同时
        可能有另个一个线程完成了入队操作 导致尾节点改变
        需要通过CAS算法来保证线程安全地入队
        * 多线程下入队的步骤
            1. 定位尾节点
            由于在并发情况下 尾节点可能是tail节点 也可能是tail的next节点
            所以每次入队都要先通过tail节点来找到尾节点
                * 原理
                首先判断tail节点是否有next 如果有
                需要用p来指向tail节点 并通过不断获取next节点
                直到找到next为null的节点 此时p为尾节点 完成了定位
                获取p的next时有一种特殊情况是
                p和p的next节点相等 只有一种可能就是两者都为空
                此时队列刚刚初始化 需要返回head节点
            2. 使用CAS将入队节点设置为尾节点的下一个节点 直到成功为止
                * 原理
                定位了尾节点后 p将指向尾节点
                将通过p.casNext(null,n)将入队节点设置为尾节点的next节点
                如果失败则说明其他线程更新了尾节点 需要重新定位尾节点
            3. 更新tail引用
            接着是更新tail引用 即将tail引用最新的尾节点
            该操作允许失败 可以由其他并发的线程入队并更新tail引用
            4. HOPS
                * HOPS的目的是用来减少CAS更新tail引用的次数
                当tail引用节点与尾节点的距离大于HOPS(默认值为1)
                才CAS更新tail引用
                * 这样可以提高效率：虽然因为距离越远循环寻找next次数越多
                导致增加了定位尾节点的时间 但通过增加对volatile变量的读
                减少了对volatile变量的写 由于写的开销远大于读
                所以可以减少许多volatile变量写操作的开销 提高效率
        * 源码
        ```java
        public boolean offer(E e) {
            checkNotNull(e);
            //入队元素生成新的节点
            final Node<E> newNode = new Node<E>(e);
            
            //用p引用tail 不断寻找next 直到next为空 则说明p指向了最后一个节点
            for (Node<E> t = tail, p = t;;) {
                Node<E> q = p.next;
                //此时p指向最后一个节点
                if (q == null) {
                    //尝试将入队元素设置为最后一个节点的下一个节点
                    if (p.casNext(null, newNode)) {
                        //如果p和t不等说明tail需要更新
                        if (p != t) 
                            //更新tail引用
                            casTail(t, newNode);  
                        return true;
                    }
                }
                //如果p和p的next相等 说明两者都为空 说明队列已空
                //如果tail没有改变即没有元素入队 需要返回head
                else if (p == q)
                    p = (t != (t = tail)) ? t : head;
                else
                    //如果为尾节点发生变化且p不等于尾节点 则重新定位到最新的尾节点
                    p = (p != t && t != (t = tail)) ? t : q;
            }
        }
        ```
* 出队
出队需要返回首个节点元素怒 并清空该节点对元素的引用
但并不是每次出队操作都更新head引用 也通过HOPS减少CAS更新head的次数
    * 原理
    首先获取tail节点 判断tail节点中元素是否为空
        1. 如果为空 则已经有其他线程将tail节点中元素取走
        继续寻找next 定位头节点
        2. 如果不为空 当前节点为头节 点尝试CAS更新头节点中元素引用为null
            * 如果CAS成功 继续查看头节点和head的距离是否超过HOPS
            如果超过则更新head引用为最新的头节点
            这之后返回元素
            * 如果CAS不成功 则已经有其他并发线程出队当前元素
            需要重新定位头节点
    * 源码
    ```java
    public E poll() {
        //重新定位头节点的入口
        restartFromHead:
        for (;;) {
            //p从head节点开始直到寻找到元素引用不为空的节点
            for (Node<E> h = head, p = h, q;;) {
                E item = p.item;
                //此时p指向的节点中的元素不为空 为头节点
                //尝试将头节点的元素CAS更新为null
                if (item != null && p.casItem(item, null)) {
                    //如果CAS更新元素为null成功
                    //如果p与head不等 需要更新head引用为最新头节点
                    if (p != h) 
                        updateHead(h, ((q = p.next) != null) ? q : p);
                    return item;
                }
                //如果p的下一个节点为空 则说明队列已经空了 需要更新头节点
                else if ((q = p.next) == null) {
                    updateHead(h, p);
                    return null;
                }
                //如果已经找到了末尾还没寻找到头节点 重新回到入口定位头节点
                else if (p == q)
                    continue restartFromHead;
                else
                //否则继续向后寻找头节点
                    p = q;
            }
        }
    }
    ```
#### Java中的阻塞队列
* 阻塞队列
    * 阻塞队列就是支持阻塞插入和移除元素的队列
        1. 阻塞插入：当队列满时 插入元素的线程会被阻塞 直到队列不满
        2. 阻塞移除：当队列空时 获取元素的线程会被阻塞 直到队列不空
    * 阻塞队列的适用场景：常用于生产者与消费者模式
    生产者向阻塞队列插入元素 消费者从阻塞队列获取元素
    * 当阻塞队列因为满或空不可用时 有四种处理方式：
        1. 抛出异常 对应方法为add remove
        2. 返回特殊值 对应方法为offer poll
        3. 一直阻塞 对应方法为put take
        4. 超时退出 对应方法为offer poll
* Java中的阻塞队列
    1. ArrayBlockingQueue
    是用数组实现的有界阻塞队列 可以指定访问的公平性
    公平性通过重入锁实现
        ```java
        public ArrayBlockingQueue(int capacity, boolean fair) {
            if (capacity <= 0)
                throw new IllegalArgumentException();
            //初始化数组
            this.items = new Object[capacity];
            //初始化重入锁 实现访问的公平性设置
            lock = new ReentrantLock(fair);
            //用Condition实现等待/通知
            notEmpty = lock.newCondition();
            notFull =  lock.newCondition();
        }
        ```
    2. LinkedBlockingQueue
    是用链表实现的有界阻塞队列 默认及最大长度为Integer.MAX_VALUE
    3. PriorityBlockingQueue
    是无界优先阻塞队列 默认情况下为升序
    可以覆写compareTo或者传入Comparator对象来规定排序规则
    4. DealyQueue
        * 是支持延迟获取的无界阻塞队列 它是是用优先队列实现的
        入队的元素需要实现Delayed接口 只有到达相应的延迟时间后才能获取
        * DelayQueue的运用场景
            1. 缓存系统：
            用DelayQueue保存缓存的有效期 有一个线程循环查询该队列
            一旦可以从其中获取到元素 说明相应缓存已经到期了
            2. 定时任务调度：
            将需要执行的任务和任务时间存储在DealyQueue中
            一旦从DelayQueue中获取到任务就执行
        * 使用DelayQueue的关键在于让队列元素实现Delayed接口
            1. 初始化元素时 需要指定延迟到的时刻 time
            以及元素的标号sequenceNumber来标识先后顺序
            2. 实现getDelay()返回当前元素还需要延迟多久(纳秒)
            3. 实现compareTo来指定延迟队列中的排序规则
            ```java
            public class DelayedElement implements Delayed {
                private long time;
                private final static AtomicLong sequencer=new AtomicLong(0);
                private long sequenceNumber;
                public DelayedElement(long time){
                    //初始化延迟到何时
                    this.time=time;
                    //初始化元素标号
                    sequenceNumber=sequencer.getAndIncrement();
                }
                @Override
                public long getDelay(TimeUnit unit) {
                    //返回还需要延迟多久(毫秒)
                    return unit.convert(time-System.nanoTime(),TimeUnit.NANOSECONDS);
                }
            
                @Override
                public int compareTo(Delayed delayed) {
                    //如果是同一个元素 则相同
                    if (delayed==this)
                        return 0;
                    
                    //如果是同类元素 比较延迟时间
                    if (delayed instanceof DelayedElement){
                        DelayedElement de=(DelayedElement)delayed;
                        long diff=time-de.time;
                        if (diff<0)
                            return -1;
                        else if (diff>0)
                            return 1;
                        else if (sequenceNumber<de.sequenceNumber)
                            return -1;
                        else 
                            return 1;
                    }
                    
                    //如果不是同类元素 比较需要延迟多久来决定
                    long d=getDelay(TimeUnit.NANOSECONDS)-delayed.getDelay(TimeUnit.NANOSECONDS);
                    
                    if (d==0)
                        return 0;
                    else if (d>0)
                        return 1;
                    else 
                        return -1;
                }
            }
            ```
        * 实现延时阻塞队列
        当线程尝试获取元素时 如果没有到达延迟时间就阻塞当前线程
            ```java
            public E take() throws InterruptedException {
                final ReentrantLock lock = this.lock;
                lock.lockInterruptibly();
                try {
                    for (;;) {
                        //获取队首元素
                        E first = q.peek();
                        if (first == null)
                        //如果队首元素为空 则阻塞
                            available.await();
                        else {
                        
                            long delay = first.getDelay(NANOSECONDS);
                            //如果延迟时间已到 则获取到元素
                            if (delay <= 0)
                                return q.poll();
                            first = null; 
                            //在未到达延迟时间的情况下
                            //leader为等待头部元素的线程 如果不空
                            //则说明已经有线程在等待头部元素
                            //当前线程等待通知
                            if (leader != null)
                                available.await();
                            else {
                            //否则当前线程成为等待头部元素的线程 
                            //等待头部元素延迟时间到期
                                Thread thisThread = Thread.currentThread();
                                leader = thisThread;
                                try {
                                    available.awaitNanos(delay);
                                } finally {
                                    if (leader == thisThread)
                                        leader = null;
                                }
                            }
                        }
                    }
                } finally {
                    //如果无线程等待头部节点或者非空 则通知等待在队列上的线程
                    if (leader == null && q.peek() != null)
                        available.signal();
                    lock.unlock();
                }
            }
            ```
    5. SynchronousQueue
    是不存储元素的阻塞队列 每次put必须等待一个take 支持设置访问的公共性
    它如同传球手 负责将生产者线程的结果直接传递给消费者线程
    它本身不存储元素 吞吐量非常高
    6. LinkedTransferQueue
    是由链表组成的无界阻塞TransferQueue
    相比其他队列 多了transfer和tryTransfer方法
        1. transfer
        如果有消费者线程在等待 则将生产者传入的元素立刻传输给消费者
        否则将元素放入tail 并等待元素被消费者消费后才返回
        实现方法：
        先将元素设置为tail节点 再自旋等待消费者消费
        长时间自旋后会通过Thread.yeild()暂停当前线程来减少CPU消耗
        2. tryTransfer
        会在尝试将生产者入队元素立刻传输给消费者 不管是否成功
        将立刻返回或者超时等待
    7. LinkedBlockingDeque
    是由链表组成的双向阻塞队列 可以从两端插入/移除元素 减少一半的竞争
* 阻塞队列实现原理
    * 阻塞队列使用通知模式实现
    当队列满时会阻塞入队操作线程 当队列不满时通知阻塞的入队操作线程
    当队列空时会阻塞出队操作线程 当队列不空时通知阻塞的出队操作线程
    ```java
    public class BoundedQueue {
        //用数组实现有界队列
        private Object[] elements;
        //用于存放入队/出队时存放元素的下标
        //以及队列中元素的数量
        private int addIndex,removeIndex,count;
    
        //锁对象
        private Lock lock=new ReentrantLock();
    
        //Condition对象 用于建立等待/通知模型
        //full Condition对象 当有界队列满时 线程的入队操作被阻塞
        private Condition full=lock.newCondition();
        //empty Condition对象 当有界队列空时 线程的出队操作被阻塞
        private Condition empty=lock.newCondition();
    
        public BoundedQueue(int size){
            //如果初始化长度不大于0 抛出异常
            if (size<=0)
                throw new IllegalArgumentException("队列的长度必须大于0");
    
            elements=new Object[size];
        }
    
        //入队操作
        public void add(Object element) throws InterruptedException {
            //对数组操作前加锁 保证可见性和排他性
            lock.lock();
            try {
                //当队列已满 当前线程等待直到队列有空位
                //循环判断是否满足条件
                //防止过早/意外通知导致线程操作的不正确
                while (count==elements.length)
                    full.await();
    
                //有空位时 入队
                elements[addIndex++]=element;
    
                //有界队列采用下标循环的形式来充分利用空间
                if (addIndex==elements.length)
                    addIndex=0;
    
                //入队后元素数量加1
                count++;
                //通知正在等待出队操作的一个线程 条件已经改变
                empty.signal();
            } finally {
                //保证锁最终能够释放
                lock.unlock();
            }
        }
    
        //出队操作
        public Object remove() throws InterruptedException {
            //对数组操作前加锁 保证可见性和排他性
            lock.lock();
            try {
                //当队列为空时 当前线程等待直到队列有元素可以出队
                //采用循环防止过早/意外通知导致线程操作不正确
                while (count==0)
                    empty.await();
    
                //出队
                Object element=elements[removeIndex++];
    
                //有界数组通过下标循环来充分利用空间
                if (removeIndex==elements.length)
                    removeIndex=0;
    
                //出队后队列元素减1
                count--;
    
                //通知正在等待入队操作的一个线程 条件已经改变
                full.signal();
    
                //返回出队元素
                return element;
            } finally {
                //保证最终锁能够释放
                lock.unlock();
            }
    
        }
    }
    ```
    * 阻塞最终会通过Lock.park(Object blocker)使线程进入WAITING状态
    以下四种情况会使被park阻塞的线程从park返回：
        1. 执行相应的unpark方法
        2. 线程被中断
        3. 阻塞超时
        4. 发生未知异常
    ```java
    public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            Node node = addConditionWaiter();
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            while (!isOnSyncQueue(node)) {
                //最终将会调用park来阻塞线程
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) 
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
    }
    ```
    * Lock.park(Object blocker)的实现：
        1. 用setBlocker保存要阻塞的线程的阻塞对象
        2. 调用unsafe.park()根据不同操作系统的实现来阻塞当前线程
        3. 从park返回后用setBlocker解除阻塞线程的阻塞对象
        ```java
        public static void park(Object blocker) {
            Thread t = Thread.currentThread();
            setBlocker(t, blocker);
            UNSAFE.park(false, 0L);
            setBlocker(t, null);
        }
        ```
#### Fork/Join框架
* Fork/Join框架是用于并行执行任务的框架
    * Fork
    就是将一个大任务切分为若干个子任务并行执行
    * Join
    就是将这些子任务的执行结果合并从而得到大任务的结果
* 工作窃取算法
    * 工作窃取算法指的是某个线程窃取其他线程的任务队列中的任务来执行
    * 应用场景：
    对于一个大任务 将其划分为若干个子任务放入不同队列中
    创建若干个工作线程 一个工作线程对应执行一个任务队列中的任务
    如果有一个线程提前执行完了自己队列中的任务
    就通过可以窃取其他队列中的任务来提高效率
    * 注意：
    由于在一个线程在窃取任务时可能与被窃取的线程发生竞争
    存放任务的队列就需要采用双端队列 并且按照以下规则使用： 被窃取的线程永远从队列的头部取出任务并执行
    窃取的线程永远从队列的尾部取出任务并执行
    以此来减少线程间竞争的可能
    * 优点：
    充分利用线程并行计算 减少线程间竞争
    * 缺点：
    当双端队列中只有一个线程时 仍然存在线程间竞争
    创建了多个线程与双端队列 耗费了更多的系统资源
* Fork/Join框架的设计
    * 分为两个步骤
        1. 分割任务：
        将大任务分割为足够小的任务
        2. 合并子任务执行结果：
        将分割好的子任务分散到多个双端队列
        启动对应个数的线程来执行相应队列中的任务
        并将每个子任务的执行结果放入同一个队列中
        启动一个线程将该队列中的数据取出并合并
    * 实现设计
        1. ForkJoinTask：一个类通过继承RecursiveTask/Action来成为一个无/有返回结果的任务 其中包含了fork/join的操作机制
        2. ForkJoinPool：该类调用若干工作线程来执行若干双端队列中的子任务
        会采用工作窃取的方式进行调度
* Fork/Join框架的使用
    * 使用步骤
        1. 创建任务类 需要继承RecursiveTask/Action来成为一个ForkJoinTask
        2. 定义一个属性表示阈值 指示子任务的最大程度 即何时子任务足够小
        3. 覆写compute方法
            * 该方法在子任务足够小(小于阈值)时直接执行任务
            * 如果不是足够小 则将当前任务划分为若干个子任务
            随后调用这些子任务的fork方法 使其加入对应的双端队列
            这之后调用这些子任务的join()方法来执行并等待子任务完成
            这之后将子任务的执行结果合并起来
            方法最后返回当前子任务的最终结果
        4. 执行大任务
        从客户端初始化大任务的ForkJoinTask对象 并创建ForkJoinPool对象
        将大任务交给ForkJoinPool对象执行 并用Future对象接收执行结果
        5. 查看异常
        在客户端通过ForkJoinTask对象的isCompletedAbnormally
        来检查任务执行时是否发生了异常 如果有异常
        进一步调用ForkJoinTask对象的getException()来获取异常
    * 使用实例
    用Fork/Join框架完成数字累加
        ```java
        public class AccumulationTask extends RecursiveTask<Integer> {
            //用于表示累加的开始数字和结束数字
            private int begin;
            private int end;
        
            //用于存放子任务规模大小的阈值
            //这里即是子任务的最大规模为2个数字相加
            private static final int THRESHOLD=2;
        
            //传入累加任务的开始与结束的数字
            public AccumulationTask(int begin,int end){
                this.begin=begin;
                this.end=end;
            }
        
            @Override
            protected Integer compute() {
                //用于存放当前子任务的执行结果
                int sum=0;
        
                //首先来查看任务的规模大小是否小于阈值
                if (end-begin+1<=THRESHOLD){
                    //如果小于阈值则说明子任务已经足够小 直接执行任务
                    //完成从begin到end的累加
                    for (int i=begin;i<=end;i++)
                        sum+=i;
        
                }else {
                    //否则子任务太大 需要进一步划分
                    int mid=(begin+end)/2;
        
                    //将当前子任务划分为两个更小的子任务
                    AccumulationTask leftTask=new AccumulationTask(begin,mid);
                    AccumulationTask rightTask=new AccumulationTask(mid+1,end);
        
                    //将划分好的两个子任务放入双端队列中
                    leftTask.fork();
                    rightTask.fork();
        
                    //等待两个子任务执行完成
                    int leftResult=leftTask.join();
                    int rightResult=rightTask.join();
        
                    //将子任务的执行结果合并
                    sum=leftResult+rightResult;
                }
        
                //最后把最终结果返回
                return sum;
            }
        }
        
        //测试类
        public class ForkJoinTest {
            @Test
            public void test() throws ExecutionException, InterruptedException {
                //初始化大任务为ForkJoinTask对象
                AccumulationTask task=new AccumulationTask(1,5);
                //创建ForkJoinPool对象
                ForkJoinPool pool=new ForkJoinPool();
        
                //用ForkJoinPool对象执行 大任务 并用Future来接收最终结果
                Future<Integer> result=pool.submit(task);
                //输出运行结果
                System.out.println(result.get());
        
                //查看任务执行过程中是否有异常发生 如果有异常发生 输出异常
                if (task.isCompletedAbnormally()){
                    System.out.println(task.getException());
                }
            }
        }
        ```
* Fork/Join框架的实现原理
ForkJoinPool中包含ForkJoinTask数组和ForkJoinWorkThread数组
ForkJoinTask数组将需要执行的代码交给任务
ForkJoinWorkThread数组执行任务
    * ForkJoinTask的fork方法实现原理
    fork方法用来异步执行任务
    调用了某个任务的fork方法后
    会将当前任务放入当前工作线程的双端队列中
    或者当前线程并不是工作线程 则将当前任务放入公共的双端队列中
    再调用ForkJoinPool的signalWork来唤醒或者创建一个工作线程来执行
        ```java
        public final ForkJoinTask<V> fork() {
            Thread t;
            //如果当前线程是工作线程 则将当前任务加入当前工作线程的双端队列中
            if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
                ((ForkJoinWorkerThread)t).workQueue.push(this);
            else
                //否则将当前任务加入共有双端队列中
                ForkJoinPool.common.externalPush(this);
            return this;
        }
        
        final void push(ForkJoinTask<?> task) {
            ForkJoinTask<?>[] a; ForkJoinPool p;
            int b = base, s = top, n;
            if ((a = array) != null) {    // ignore if queue removed
                int m = a.length - 1;     // fenced write for task visibility
                U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);
                U.putOrderedInt(this, QTOP, s + 1);
                if ((n = s - b) <= 1) {
                    if ((p = pool) != null)
                        //唤醒获创建一个工作线程来执行任务
                        p.signalWork(p.workQueues, this);
                }
                //如果超过ForkJoinTask的数组长度则对其扩充
                else if (n >= m)
                    growArray();
            }
        }
        ```
    * ForkJoinTask的join方法实现原理
    join用于阻塞并等待获取任务的执行结果
    首先为调用doJoin()来查看当前任务的状态
    如果是NORMAL则任务已完成 直接返回任务结果
    如果是CANCELLED 则被取消 抛出cancellationException
    如果是EXECEPTIONAL 则抛出异常 则抛出相应异常即可
        ```java
        public final V join() {
            int s;
            //调用doJoin()来查看任务状态
            if ((s = doJoin() & DONE_MASK) != NORMAL)
            //如果不是NORMAL状态则需要进一步根据状态抛出异常
                reportException(s);
                //否则正常返回结果
            return getRawResult();
        }
        
        private void reportException(int s) {
            if (s == CANCELLED)
                throw new CancellationException();
            if (s == EXCEPTIONAL)
                throw(getThrowableException());
        }
        ```
        doJoin()首先查看任务状态 如果完成则直接返回任务状态
        如果没完成则将当前任务从任务数组中取出并执行
        如果顺序完成则设置任务状态为NORMAL
        若出现异常则将状态设置为EXECEPTIONAL并记录异常
        ```java
        private int doJoin() {
            int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
            //首先查看任务状态 如果小于0说明完成了 直接返回
            //否则从当前工作线程的workQueue中取出任务并执行
            //执行完后将任务状态返回 否则一直阻塞直到完成并返回状态
            return (s = status) < 0 ? s :
                ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
                (w = (wt = (ForkJoinWorkerThread)t).workQueue).
                tryUnpush(this) && (s = doExec()) < 0 ? s :
                wt.pool.awaitJoin(w, this, 0L) :
                externalAwaitDone();
        }
        ```
## Java中的13个原子操作类
Atmoic包中的原子操作类用于简单、高效、线程安全地更新一个变量
这些类基本都是用Unsafe实现的包装类
#### 原子更新基本类型类
* 以下三个类原子地更新基本类型：
    AtmoicBoolean、AtomicInteger、AtomicLong 这些类的方法几乎一模一样
* 以AtmoicInteger为例 其常用方法：
    * int addAndGet(int delta)
    以原子方式将输入值与旧值相加 并返回结果
    * boolean compareAndSet(int expect,int update)
    如果期望值等于旧值 则原子地更新值
    * int getAndIncrement()
    以原子方式自增 返回旧值
    * void lazySet(int newValue)
    延迟一段时间后再将值设置为输入值
    * int getAndSet(int newValue)
    原子地设置为新值且返回旧值
* 使用实例
用主线程去自增原子基本类型
    ```java
    public class AtomicIntegerTest {
        private static final AtomicInteger ai=new AtomicInteger(1);
        public static void main(String[] args) {
            //原子操作 先获取旧值 再自增
            System.out.println(ai.getAndIncrement());
            System.out.println(ai.get());
        }
    }
    ```
* 实现原理
    * getAndIncrement()
    通过循环CAS来完成原子地加1并返回旧值
    在循环中首先获取到旧值 然后获得旧值+1的值
    再通过compareAndSet来更新值
    如果旧值就是期望的值
    则说明该值未被其他线程修改过 更新值并返回true
    如果旧值不是期望的值
    则说明该值已经被其他线程修改过 返回false并继续循环
    直到CAS更新值成功后返回旧值
        ```java
           public final getAndIncrement(){
               for(;;){
                   int current=get();
                   int next=current+1;
                   if(compareAndSet(current,next))
                        return current;
               }
           } 
        ```
    * compareAndSet()
    通过调用Unsafe中的compareAndSwapInt实现的
        ```java
        public final boolean compareAndSet(int expect, int update) {
            return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
        }
        ```
    * UnSafe中有三种方法
    compareAndSwapObject、compareAndSwapInt、compareAndSwapLong
    这些方法用于根据不同系统来进行原子更新Object、int、long类型变量
    对于其他基本类型 都是将自身转换为这三种类型后
    再通过这些方法来完成原子更新的
        ```java
        
        public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);
    
        public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
    
        public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);
        ```
#### 原子更新数组
* 以下四个类用于原子更新数组中的某个元素：
AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray
* 以AtomicIntegerArray为例 其常用方法：
    * int addAndGet(int i,int data)
    以原子方式将下标为i的元素与输入值相加 返回结果
    * boolean compareAndSet(int i,int expect,int update)
    如果下标为i的元素旧值等于期望值 则原子地更新下标为i的元素值
* 注意
构造AtomicXxxArray实例时 通过构造方法传入数组 会将数组复制一份
所以通过该实例对其内部数组进行修改时 不会影响传入的数组
* 使用实例
用主线程去修改原子数组
    ```java
    public class AtomicIntegerArrayTest {
        private static final int[] values={1,2,3};
        private static final AtomicIntegerArray aia=new AtomicIntegerArray(values);
        public static void main(String[] args) {
            //原子操作 先获取旧值再设置新值
            System.out.println(aia.getAndSet(1,4));
            System.out.println(aia.get(1));
        }
    }
    ```
#### 原子更新引用类型
* 如果需要原子地更新多个变量 就需要将这些变量构成一个类
* 用以下三个类原子更新引用类型：
AtomicReference、AtomicReferenceFieldUpdater(引用类型的中的字段)、
AtomicMarkableReference(带有标记位的引用) 原子更新布尔标志位和引用
* 使用实例
原子地修改引用
    ```java
    public class AtomicReferenceTest {
        private static final AtomicReference<Student> ar=new AtomicReference<>();
        public static void main(String[] args) {
            //设置引用
            Student s1=new Student("Sun",20);
            ar.set(s1);
    
            Student s2=new Student("Sun",25);
            //原子地更新更新引用
            ar.compareAndSet(s1,s2);
    
            //输出新的引用中的年龄
            System.out.println(ar.get().age);
        }
    }
    
    public class Student {
        public String name;
        public int age;
    
        public Student(String name, int age) {
            this.name = name;
            this.age = age;
        }
    }
    ```
#### 原子更新字段类
* 以下四个类用于原子地更新某个类的某个字段：
AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、
AtomicStampedReference(原子更新待版本号的引用类型 用于解决ABA问题)
* 使用
    1. 由于原子更新字段类都是抽象类
    所以需要使用静态方法newUpdater()来创建更新器
    创建更新器时需要指定要更新的类和属性
    2. 更新的字段(属性)必须用public volatile修饰
* 实例
用主线程原子地增加学生对象的年龄
    ```java
    public class AtomicIntegerFieldUpdaterTest {
        //通过静态方法构建更新器 需要指明更新的类和属性名称
        private static final AtomicIntegerFieldUpdater aifu=
        AtomicIntegerFieldUpdater.newUpdater(Student.class,"age");
    
        public static void main(String[] args) {
            //创建学生对象
            Student student=new Student("Sun",20);
            //原子地自增学生对象的年龄返回结果
            System.out.println(aifu.incrementAndGet(student));
        }
    }
    
    public class Student {
        public String name;
        public volatile int age;
    
        public Student(String name, int age) {
            this.name = name;
            this.age = age;
        }
    }
    ```
## Java中的并发工具类
#### 等待多线程完成的CountDownLatch
* CountDownLatch用于使一个或多个线程等待其他线程完成操作
* 使用方法
    1. 构建CountDownLatch实例
    通过构造函数传入count参数来作为计数器 表示要等待多少个点完成
    2. 调用await()
        * 一般是将CountDownLatch引用传入线程内
        让想要等待这些点完成的线程调用CountDownLatch对象的await()
        * 调用await()的线程将被阻塞直到计数器为0
        如果不想一直等待 可以改用超时await()
    3. 调用countDown()
    每执行完一个点 调用一次CountDownLatch对象的countDown()
    使计数器减一
    4. 解除阻塞
    直到所有需要执行的点完成后 计数器减至0
    所有阻塞在该CountDownLatch对象上的线程将解除阻塞
    继续执行后继逻辑
* 使用实例
主线程等待其他10个线程完成任务后再结束
    ```java
    public class CountDownLatchTest {
        //初始化计数器为10 主线程将等待10个点完成后再结束
        private static final CountDownLatch latch=new CountDownLatch(10);
        public static void main(String[] args) throws InterruptedException {
            for (int i = 0; i <10 ; i++) {
                Thread thread=new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            //任务耗时500毫秒
                            Thread.sleep(500);
                            
                            //当任务完成时 计数器减1
                            System.out.println(Thread.currentThread().getName()+" completed its mission");
                            latch.countDown();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                });
                
                thread.start();
            }
            
            //主线程等待其他10个线程完成任务才终止
            latch.await();
            System.out.println("all missions have completed,"+Thread.currentThread().getName()+" terminated");
            
        }
    }
    ```
#### 同步屏障 CyclicBarrier
* CyclicBarrier即可循环使用的屏障
让一组线程到达一个屏障(同步点)时被阻塞 直到最后一个线程到达屏障时
屏障打开 被屏障拦截的线程才能继续执行
* 使用方法
    1. 创建CylicBarrier实例 通过构造函数传入屏障拦截的线程数量
    2. 线程调用CylicBarrier对象的await() 表示当前线程到达屏障 当前线程被阻塞
    3. 直到到达屏障的线程数到达屏障期望拦截数量 被屏障拦截的线程继续执行
    4. 另一构造方法可以传入barrierAction来指定当屏障打开时优先执行的代码
* 使用实例
    ```java
    public class CyclicBarrierTest {
        //同步屏障的拦截数量为2 即当有两个线程到达屏障后将打开屏障
        //屏障打开后优先执行barrierAction中的代码
        private static final CyclicBarrier barrier=new CyclicBarrier(2,new barrierAction());
    
        public static void main(String[] args) throws BrokenBarrierException, InterruptedException {
            //创建一个线程 在屏障打开后它输出1
            Thread thread=new Thread(new Runnable() {
                @Override
                public void run() {
                    //到达屏障
                    try {
                        barrier.await();
                        //屏障打开后输出1
                        System.out.println(1);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
            thread.start();
    
            //主线程到达屏障 此时已经满足两个线程到达屏障 屏障将会打开
            barrier.await();
            //主线程在屏障打开后输出2
            System.out.println(2);
    
            //屏障打开后 会先输出3
            //由于并发的原因后面可能按照 1 2 或者 2 1 的顺序输出
        }
    }
    
    class barrierAction implements Runnable{
    
        //在屏障打开后优先执行的代码
        @Override
        public void run() {
            System.out.println(3);
        }
    }
    ```
* 应用场景
用于多线程计算数据 最终合并计算结果的场景
当多个线程完成计算后到达同步屏障
优先执行barrierAction中的代码合并计算结果
    ```java
    public class CyclicBarrierApp {
        //用于存放每个线程的计算结果
        private static final ConcurrentHashMap<String,Integer> map=new ConcurrentHashMap<>();
        //同步屏障 用于拦截线程
        //且在拦截的线程到达指定数量时优先执行合并线程合并结果
        private static final CyclicBarrier barrier=new CyclicBarrier(10, new Runnable() {
            @Override
            public void run() {
                //用于存放合并结果
                int totalResult=0;
    
                //取出结果集合
                Collection<Integer> results=map.values();
                for (Integer result:
                     results) {
                    totalResult+=result;
                }
    
                //将合并的结果放入容器中
                map.put("result",totalResult);
            }
        });
    
        public static void main(String[] args) throws InterruptedException {
            //创建10个线程 分别计算后将结果放入容器
            //这之后屏障打开 合并线程优先执行
            //其工作完成后 其他线程继续输出最终结果
            for (int i = 0; i <10 ; i++) {
                int finalI = i;
                Thread thread=new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            //模拟计算
                            Thread.sleep(500);
                            System.out.println(Thread.currentThread().getName()+" completed the computing mission,result is "+finalI);
    
                            //将计算结果放入容器
                            map.put("result"+ finalI,finalI);
                            //到达屏障 等待打开屏障后合并结果
                            barrier.await();
    
                            //因为合并结果的线程率先执行 所以当前线程在合并线程执行完后输出得到最终结果
                            System.out.println(Thread.currentThread().getName()+" get the final result:"+map.get("result"));
    
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                });
                thread.start();
            }
    
        }
    }
    ```
* 与CountDownLatch的区别
    1. CountDownLatch的计数器只能使用一次
    而CyclicBarrier的计数器可以通过reset()重置从而重复使用
    (一般是计算发生错误后 重置计数器 并重新启动线程重新计算)
    2. CyclicBarrier还提供一些其他方法
        * getNumberWaiting()查看被屏障拦截的线程数量
        * isBroken() 查看被拦截的线程是否被中断过
        ```java
        public class CyclicBarrierTest {
            //同步屏障的拦截数为2
            private static final CyclicBarrier barrier=new CyclicBarrier(2);
        
            public static void main(String[] args) throws InterruptedException {
                Thread thread=new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //当前线程直接到达屏障 一会将对其进行中断
                        try {
                            //输出被同步屏障拦截的线程数
                            System.out.println(Thread.currentThread().getName()
                                    +" looks the thread number is waiting in the barrier:"
                                    +barrier.getNumberWaiting());
                            barrier.await();
                        } catch (Exception e) {
                        }
                    }
                });
                thread.start();
        
                //主线程休眠1秒 等待前一个线程到达屏障
                Thread.currentThread().sleep(1000);
        
                //主线程来中断到达屏障的线程
                thread.interrupt();
        
                //输出被同步屏障拦截的线程数
                System.out.println(Thread.currentThread().getName()
                        +" looks the thread number is waiting in the barrier:"
                        +barrier.getNumberWaiting());
        
                //主线程到达屏障
                try {
                    barrier.await();
                } catch (Exception e) {
                }
                
                //此时已经有两个线程到达了屏障 屏障将打开
                //打开屏障后主线程查看屏障拦截的线程中是否有被中断的线程
                System.out.println("Are there threads are interrupted in the barrier?");
                System.out.println("The answer is "+barrier.isBroken());
            }
        }
        ```
#### 控制并发线程数的Semaphore
* Semaphore(线程量)
用于控制访问特定资源的线程数量
当线程访问时已经超过指定数量 则该线程被阻塞
从而保证公共资源的合理使用
* 应用场景
Semaphore在公共资源有限的情况下用于流量控制
* 使用方法
    1. 创建Semaphore实例 通过构造函数传入可用的许可证数量 表示最大并发数
    2. 访问Semaphore限流资源的线程调用对应Semaphore对象的acquire()获取一个许可证
    3. 当访问限流资源结束后 线程调用Semaphore对象的release()归还许可证
    4. 当许可证被获取完后 想要申请许可证的线程将等待直到有许可证可以获取
* 使用实例
让30个线程并发尝试访问公共资源 最多只有5个线程能够真正并发访问到
    ```java
    public class SemaphoreTest {
        //信号量 用于访问公共资源时限流
        //最多只能有5个线程并发访问公共资源
        private static final Semaphore semaphore=new Semaphore(5);
        //同步屏障 用于让30个线程同时尝试访问公共资源
        private static final CyclicBarrier barrier=new CyclicBarrier(30);
    
        public static void main(String[] args) {
            //启动30个线程 都去尝试访问公共资源
            for (int i = 0; i <30 ; i++) {
                Thread thread=new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            //到达屏障
                            barrier.await();
    
                            //等30个线程都到达屏障后同时尝试访问公共资源
                            //申请访问许可证
                            semaphore.acquire();
                            //模拟访问资源耗时
                            Thread.sleep(2000);
                            System.out.println(Thread.currentThread().getName()
                                    +" access the resource");
                            //访问完毕后释放许可证
                            semaphore.release();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                });
    
                thread.start();
            }
    
            //可以看到每2秒就只有5个线程能同时访问到公共资源并输出消息
        }
    }
    ```
* 其他方法
    * int availablePermits()
    返回此Semaphore中当前可用的许可证数量
    * int getQueuedLength()
    返回正在等待获取许可证的线程数
    * boolean hasQueuedThreads()
    查看是否有等待获取许可证的线程
    * void reducePermits(int reduction)
    减少reduction个许可证
    * Collection getQueuedThreads()
    返回正在等待获取许可证的所有线程
#### 线程间交换数据的Exchanger
* Exchanger(交换者)
用于线程间的数据交换 它提供一个同步点 当两个线程到达这个同步点时
就可以进行交换彼此的数据
* 应用场景
    * 遗传算法
    交换两个人的数据 再通过交叉规则得到交配结果
    * 校对工作
    当两个线程完成容易出错的相同工作 为了避免出错
    交换工作结果进行校对
* 使用方法
    1. 创建Exchanger实例并指定泛型 表示要交换的数据类型
    2. 线程A在想要交换数据时调用Exchanger对象的exchange()
    它会一直等待其他线程调用同一Exchanger对象的exchange()
    3. 线程B在想要与线程A交换数据时调用同一Exchanger对象的exchange()
    此时线程A与线程B到达同步点 将会把格子的数据交给对方
    4. 如果两个线程中有一个线程未执行exchange() 将会有一个线程一直等待
    可以通过超时方法来避免
* 使用实例
校对录入员A的录入内容与录入员B的录入内容
    ```java
    public class ExchangerTest {
        private static final Exchanger<String> exchanger=new Exchanger<>();
    
        public static void main(String[] args) {
            //启动两个线程 线程A与线程B
            Thread threadA=new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        //首先模拟录入工作耗时
                        System.out.println(Thread.currentThread().getName()
                                +" is working");
                        Thread.sleep(1000);
                        String resultA="录入结果A";
                        System.out.println(Thread.currentThread().getName()
                                +"'s work is done,waiting to exchange result");
                        
                        //等待与线程B交换数据
                        String resultB=exchanger.exchange(resultA);
    
                        //交换数据后 开始校对录入结果
                        System.out.println(Thread.currentThread().getName()
                                +" get the exchange result:"
                                +resultB+",the result is same:"+(resultA==resultB));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            },"录入员A");
    
            Thread threadB=new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        //首先模拟录入工作耗时
                        System.out.println(Thread.currentThread().getName()
                                +" is working");
                        Thread.sleep(2000);
                        String resultB="录入结果B";
                        System.out.println(Thread.currentThread().getName()
                                +"'s work is done,waiting to exchange result");
                        
                        //等待与线程A交换数据
                        String resultA=exchanger.exchange(resultB);
    
                        //交换数据后 开始校对录入结果
                        System.out.println(Thread.currentThread().getName()
                                +" get the exchange result:"
                                +resultA+",the result is same:"+(resultA==resultB));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            },"录入员B");
    
            threadA.start();
            threadB.start();
        }
    }
    ```
## Java中的线程池
* 线程池的应用场景非常广 几乎所有需要并发执行任务时都可以使用
* 它带来的好处：
    1. 降低资源消耗
    重复利用线程来减少创建于销毁的开销
    2. 提高响应速度
    任务提交时直接分配给线程执行 而不是等待创建线程来执行
    3. 提高线程的可管理性
    可以对线程进行分配、调优与监控
#### 线程池的实现原理
* 当一个任务提交到线程池时 线程池的处理流程：
    1. 查看核心线程池是否已满(即查看核心线程池中正在运行的线程数)
        * 如果不是
        则创建一个新的工作线程来执行提交的任务
        * 否则
        进入下一个流程
    2. 查看工作队列是否已满
        * 如果不是
        则将提交的任务加入到工作队列
        * 否则
        进入下一个流程
    3. 查看整个线程池是否已满(即查看线程池中正在运行的线程数)
        * 如果不是
        则创建一个新的工作线程来执行提交的任务
        * 否则
        将提交的任务按照饱和策略来处理
* 流程图
![image](https://note.youdao.com/yws/public/resource/708ad1b1ee41c2b335e0cac5c8d83d03/xmlnote/EAF0BF903EFE4DD199A2DCE420BDB02A/9019)
* 工作线程
    * 当线程池创建线程后 会将其包装成工作线程
    它按以下方式运作：
        1. 先执行线程池创建它时指定的任务
        2. 完成指定任务后反复从工作队列中取出任务并执行
    * 源码
    工作线程的run方法
        ```java
        public void run() {
             try {
                    //首先执行线程池创建当前工作线程时交付的任务
                   Runnable task = firstTask;
                   firstTask = null;
                   //执行完后不断循环从工作队列中获取任务并执行
                    while (task != null || (task = getTask()) != null) {
                            runTask(task);
                            task = null;
                    }
              } finally {
                    //线程池销毁时会销毁当前工作线程
                     workerDone(this);
              }
        }
        ```

* ThreadPoolExecutor的execute()
    * 实现原理
        1. 如果正在运行的线程数少于corePoolSize
        则创建新的线程来执行任务(需要加全局锁)
        2. 如果正在运行的线程数大于等于corePoolSize
        则将任务加入到工作队列中
        3. 如果工作队列已满
        则创建新的线程来执行任务(需要加全局锁)
        4. 如果正在运行的线程数大于等于maximumPoolSize
        则拒绝执行任务 并调用RejectedExecutionHandler.rejectdExecution()
        来按照饱和策略来处理拒绝执行的任务
    * 源码
        ```java
        public void execute(Runnable command) {
            //如果任务为空 则抛出异常
            if (command == null)
                throw new NullPointerException();
            
            //判断线程池中线程数是否少于corePoolSize
            int c = ctl.get();
            if (workerCountOf(c) < corePoolSize) {
                //如果小于corePoolSize
                //则调用addWorker来创建新的工作线程来执行提交的任务
                if (addWorker(command, true))
                    return;
                c = ctl.get();
            }
            //如果线程数大于等于corePoolSize 则尝试将任务加入工作队列
            if (isRunning(c) && workQueue.offer(command)) {
                int recheck = ctl.get();
                if (! isRunning(recheck) && remove(command))
                    reject(command);
                else if (workerCountOf(recheck) == 0)
                    addWorker(null, false);
            }
            //如果工作队列已满 
            //则在线程数小于maximumPoolSize时 
            //尝试创建新的工作线程来执行任务
            else if (!addWorker(command, false))
                //如果线程数大于等于maximumPoolSize导致无法创建新的线程
                //则拒绝执行任务 并采用饱和策略来处理拒绝的任务
                reject(command);
        }
        ```
#### 线程池的使用
* 线程池的创建
通过ThreadPoolExecutor的构造函数来创建一个线程池
    ```java
    public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, 
    TimeUnit milliseconds, BlockingQueue<Runnable> runnableTaskQueue,
    ThreadFactory threadFactory, RejectedExecutionHandler handler)
    ```
    * corePoolSize(线程池的基本大小)
        * 当有任务提交到线程池时 如果正在运行的线程数未达到线程池的基本大小
        无论有无其他空闲线程 都会直接创建新的工作线程来执行任务
        直到线程池中线程数大于线程池的基本大小才会停止创建
        * 可以调用线程池的prestartAllCoreThreads()来预热线程池
        提前创建基本数量的线程并启动
    * runnableTaskQueue(任务队列)
    它是线程池中保存任务的任务队列 它是一个阻塞队列
    线程池中可用的阻塞队列有：
    ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、
    PriorityBlockingQueue
    其中静态工厂方法Executors.newFixedThreadPool使用了LinkedBlockingQueue
    Executors.newCachedThreadPool使用了SynchronousQueue
    * maximumPoolSize(线程池最大数量)
    当有任务提交到线程池时 如果任务队列满且运行的线程数小于最大线程数
    则创建新的工作线程执行任务
    注意：如果阻塞队列采用无界队列 那么这个参数将无效
    * threadFactory(创建线程的工厂)
    可以用工厂类按照指定格式的属性来生成线程
    例如用工厂类在线程池中按照同一名称格式来创建的工作线程
    * handler(饱和策略)
    当任务队列和线程池都满时 线程池达到了饱和
    将会把任务交给这个饱和策略来处理
        * Java的线程池中的饱和策略有：
            * AbortPolicy
            抛出异常
            * CallerRunsPolicy
            用调用者所在的线程来执行任务
            * DiscardOldestPolicy
            丢弃队列中最近的一次任务并执行当前任务
            * DicardPolicy
            丢弃掉当前任务不予处理
        * 线程池默认采用抛出异常的饱和策略
        * 也可以自己实现RejectedExecutionHandler接口来自定义策略
        一般是通过这种方法记录日志或者持久化当前不能执行的任务
    * keepAliveTime(大于基本线程数的线程活动保持时间)
    即大于基本线程数的线程空闲后存活(等待在任务队列获取任务)的时间
    如果任务多 每个线程执行时间短 就可以调高该参数来提高线程利用率
    * TimeUnit(keepAliveTIme的单位)
* 向线程池提交任务
有两种方式来向线程池提交任务：
    1. execute()
    用于提交不需要返回值的任务 需要传入实现了Runnable接口的对象
    2. submit()
    用于提交需要返回值的任务
    需要传入实现了Callable接口的对象
    该方法会返回Future对象 并通过future.get()来获取返回结果 该方法会一致阻塞到任务完成 也可以采用超时获取 不过返回时任务可能尚未完成
* 关闭线程池
有两种方法来关闭线程池
两者的原理都是遍历线程池中的每个线程并调用线程的interrupt()来中断它
无法响应中断的线程不能被终止
    * shutdown()
    将线程池状态设置为SHUTDOWN 并且会等待任务执行完后再关闭线程池
    * shutdownNow()
    将线程池状态设置为STOP 并且终止包括正在执行/暂停任务的线程
    * 用哪种需要根据提交到线程池的任务来决定
    一般采用shutdown()
    如果不需要等待任务完成就关闭线程则采用shutdownNow()
* 合理配置线程池
应该根据任务特性来配置线程池
    * 任务的特性有：
        * 任务的性质
            * CPU密集型
            应该尽可能少地分配线程 例如CPU数量+1
            * IO密集型
            执行该类型的任务的线程不是一直都在执行任务
            应该尽可能多地分配线程 例如2*CPU数量
            * 混合型
            可以将其拆分为一个CPU密集型任务和一个IO密集型任务
            如果两个任务的执行时间相差不多则可以增加吞吐量
            如果两个任务的执行时间相差较多则不宜拆分
            * 注
            可以用Runtime.getRuntime().avaiableProcessors()
            来获得及其的CPU数量
        * 任务的优先级
        高、中、低
        可以传入PriorityBlockingQueue来处理 让优先级高的任务先执行
        * 任务的执行时间
        长、中、短
        可以交给不同规模的线程池处理
        或者用优先阻塞队列来让执行时间短的任务先执行
        * 任务的依赖性
        是否依赖于其他系统资源
        依赖其他系统资源的任务在执行时
        线程在等待获取系统资源的时间较长 导致CPU空闲的时间较长
        可以增大线程数来充分利用CPU
* 有界/无界阻塞队列的选取
建议使用有界阻塞队列
因为任务队列中挤压任务过多会抛出异常从而容易增加系统稳定性和预警能力
而无界队列会使等待在任务队列里的任务越来越多从而撑满内存使整个系统崩溃
* 线程池的监控
    * 如果系统中大量使用线程池 那么对线程池进行监控可以在出现问题时
    根据线程池的使用状态来定位问题
    * 一般查看线程池的一下属性来监控线程池的状态
        * taskCount
        需要执行的任务数量
        * completedTaskCount
        已经完成的任务数量
        * largestPoolSize
        线程池启动以来创建过的最大线程数 一般用来监控线程池是否满过
        * getPoolSize
        获得线程数量(不管是活动的还是销毁的都会被计入其内)
        * getActivePoolSize
        获取活动的线程数
    * 也可以继承线程池来实现自定义线程池
    通过重写beforeExecute、afterExecute、terminated方法
    在任务执行前、后以及线程池关闭前执行代码来监控线程池状态
* 使用实例
    ```java
    public class ThreadPoolTest {
        //线程池基本大小
        private int corePoolSize = 5;
        //线程池最大大小
        private int maximumPoolSize = 15;
        //工作线程空闲后存活的时间
        //这里存活10秒
        private long keepAliveTime = 10;
        //空闲后存活时间的单位
        //这里采用秒
        private TimeUnit unit = TimeUnit.SECONDS;
        //任务队列 是一个阻塞队列
        //这里采用容量为10的有界阻塞队列
        private BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(5);
        //线程工厂 可以按照想要的格式生产工作线程
        //这里使用自定义的线程工厂 线程的名字按照 t-标号来创建
        private ThreadFactory threadFactory = new ThreadFactory() {
            private AtomicLong sequence = new AtomicLong(0);
    
            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "t-" + sequence.getAndIncrement());
            }
        };
        //饱和策略 当线程池饱和后处理不能执行的任务的策略
        //这里采用了直接抛出异常的策略
        private RejectedExecutionHandler handler = new ThreadPoolExecutor.AbortPolicy();
    
        @Test
        public void test() throws Exception {
            //创建线程池
            ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,
                    unit, workQueue, threadFactory, handler);
            //让线程池预热
            executor.prestartAllCoreThreads();
    
            //提交15个任务 每个任务需要执行1秒
            for (int i = 0; i < 15; i++) {
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            //模拟任务耗时
                            System.out.println(Thread.currentThread().getName() +
                                    " is working");
                            Thread.sleep(1000);
                            System.out.println(Thread.currentThread().getName() +
                                    " finish the work");
                            //对线程池工作状态进行监控
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                });
            }
    
            //让主线程休眠20秒 使其他线程能够完成任务
            Thread.sleep(20000);
    
            //完成任务后当前线程 输出线程池中已经完成多少任务
            System.out.println("now "+executor.getCompletedTaskCount()+" tasks are completed");
            //最后关闭线程池
            executor.shutdown();
        }
    }
    ```
## Executor框架
Java线程既是工作单元也是执行机制
但从JDK5开始 工作单元与执行机制分离
工作单元为Runnable与Callable
执行机制由Executor框架提供
#### Executor框架的两级调度模型
* HotSpot VM线程模型中将Java线程与本地操作系统线程一对一映射
Java线程启动/终止时本地操作系统也会创建/回收线程
操作系统将为本地线程分配CPU
* 两级调度模型
两级分别为应用程序与操作系统
    * 应用程序
    Java多线程程序将任务提交给Executor框架
    Executor框架将若干个任务分配给若干个线程
    * 操作系统
    操作系统将Java线程映射为本地线程
    并为本地线程分配CPU来执行任务
    * 应用程序通过Executor框架完成上层调度
    操作系统通过内核完成下层调度
    下层调度不受上层控制
* 模型图
![image](https://note.youdao.com/yws/public/resource/708ad1b1ee41c2b335e0cac5c8d83d03/xmlnote/65E640A1348A457FB41ECD4EB2D7543E/9480)
#### Executor框架结构
* 任务
被执行的任务需要实现Runnable/Callable接口
* 任务执行机制
核心接口为Executor以及继承它的ExecutorService接口
(Scheduled)ThreadPoolExecutor实现了该接口
* 异步计算结果
Future接口与实现它的FutureTask类
* 结构图
![image](https://note.youdao.com/yws/public/resource/708ad1b1ee41c2b335e0cac5c8d83d03/xmlnote/2083829E7D5F4C34BB6636BDE2D7C764/9482)
* 使用
    1. 主线程创建实现Runnable/Callable的任务
    2. 将任务交给ExecutorService执行
    3. 主线程等待任务完成
    如果有执行结果则从Future接口对象中获取
#### Executor框架成员
* ThreadPoolExecutor
一般用工厂类Executors来创建 返回的是ExecutorService对象
它可以创建三种类型的实例：
    1. FixedThreadPool
    固定线程数 适用于需要限制线程数量 服务器负载较重的的场景
    2. SingleThreadPoolExecutor
    只有单个线程 适用于需要保证顺序执行任务且只有单个线程的场景
    3. CachedThreadPool
    不限线程数 适用于执行大量短期异步任务 服务器负载较轻的的场景
* ScheduledThreadPoolExecutor
一般用工厂类Executors来创建 返回的是ScheduledExecutorService对象
它可以创建两种类型的实例：
    1. ScheduledThreadPoolExecutor
    包含若干个线程 适用于需要多个线程执行周期任务
    且限制线程数的场景
    2. SingleThreadScheduledPoolExecutor
    只包含一个线程 适用于需要保证顺序执行任务
    且只有单个线程执行周期任务的场景
* Future接口
Future接口与FutureTask类用来获取异步计算结果
当任务交给相应Executor的submit提交任务时
将返回实现Future接口的对象(现在的版本是返回FutureTask)
* Runnable/Callable接口
Runnable/Callble接口的实现类可以被相应Executor执行
可以用工具类Executors将Runnable的实现类包装为Callable的实现类
    ```java
    public class TestExecutors {
        @Test
        public void test(){
            //用Executors工具类将实现Runnable的对象包装为实现Callable的对象
            Callable<?> callable=Executors.callable(new Runnable() {
                @Override
                public void run() {
                    System.out.println("I become a Callable");
                }
            });
            //创建只含一个线程的ExecutorService执行包装好的callable对象
            ExecutorService executor= Executors.newSingleThreadExecutor();
            //用Future来获得执行结果
            Future<?> future=executor.submit(callable);
            //用future对象取消任务的执行
            future.cancel(false);
        }
    }
    ```
### ThreadPoolExecutor详解
Executors可以创建以下三种类型的ThreadPoolExecutor
#### FixedThreadPool
* 为可重用固定线程数的线程池
* 线程池相关配置
线程池的基本大小与最大大小都是创建时指定的线程数
大于基本线程数的空闲线程的存活时间为0 即大于基本线程数的空闲线程立即终止
采用无界阻塞队列LinkedBlockingQueue作为任务队列
    ```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
            return new ThreadPoolExecutor(nThreads, nThreads,
                                          0L, TimeUnit.MILLISECONDS,
                                          new LinkedBlockingQueue<Runnable>());
    }
    ```
* execute()运行机制
    1. 当线程数少于基本大小 创建新线程来执行任务
    2. 当线程数等于基本大小 将提交的任务加入任务队列
    3. 当线程完成指定的任务后将反复从任务队列中取出任务并执行
* 采用无界阻塞队列作为任务队列
这导致了线程数小于等于基本大小 maximumPoolSize、keepAliveTime参数失效
当线程池预热后 任务提交后都会加入到任务队列 线程池永远不会饱和 饱和策略失效
#### SingleThreadExecutor
* 为单线程的线程池
* 线程池相关配置
除了基本大小与最大大小为1外其他参数与FixedThreadPool相同
    ```java
    public static ExecutorService newSingleThreadExecutor() {
            return new FinalizableDelegatedExecutorService
                (new ThreadPoolExecutor(1, 1,
                                        0L, TimeUnit.MILLISECONDS,
                                        new LinkedBlockingQueue<Runnable>()));
    }
    ```
* execute()运行机制
    1. 如果线程数等于0 则创建一个线程执行任务
    2. 如果线程数等于1 则将提交的任务加入到任务队列
    3. 当线程池中单个线程完成指定的任务后将反复从任务队列中取出任务并执行
#### CachedThreadPool
* 为根据需要创建新线程的线程池
* 线程池相关配置
线程池的基本大小为0 最大大小不限
多于基本线程数的空闲线程的存活时间为60s
采用SynchronousQueue作为任务队列
这意味着在没有空闲线程时 每提交一个任务就创建一个新线程
    ```java
    public static ExecutorService newCachedThreadPool() {
            return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                          60L, TimeUnit.SECONDS,
                                          new SynchronousQueue<Runnable>());
    }
    ```
* execute()运行机制
    1. 调用SynchronousQueue的offer()来尝试将任务加入到任务队列中
        * 如果线程池中有空闲的线程并阻塞在SynchronousQueue的poll()
        则将任务交给该空闲线程来执行
        * 否则创建一个新的线程并将任务交给它执行
    2. 执行完指定任务的线程将成为空闲线程
    调用SynchronousQueue的poll()并阻塞来等待获取任务
    在60s内如果有任务提交则执行提交的任务
    如果阻塞在SynchronousQueue上的线程超过60s将终止
    因此长时间空闲的CachedThreadPool并不消耗资源
### ScheduledThreadPoolExecutor详解
* ScheduledThreadPoolExecutor继承自ThreadPoolExecutor 用于延迟/定期任务的执行 
* 功能与Timer类似 但Timer只有单线程 而ScheduledThreadPoolExecutor可以有多个线程
* ScheduledThreadPoolExecutor采用无界的DelayQueue 最大线程数参数无效
#### ScheduledThreadPoolExecutor运行机制
1. 调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()
/scheduleWithFixedDelay()
会向DelayQueue添加一个实现了RunnableScheduledFutur接口的
ScheduledFutureTask
2. 线程池中的线程从DelayQueue中获取任务(ScheduledFutureTask)并执行
#### ScheduledThreadPoolExecutor的实现
* ScheduledFutureTask
其中包含以下三个属性
    1. time
    任务执行的时间
    2. sequenceNumber
    任务提交到线程池的序号
    3. period
    任务执行的间隔周期
* DelayQueue
DelayQueue中封装一个PriorityQueue
对任务队列中的周期任务(ScheduledFutureTask)排序
将time小的和time相同sequenceNumber小(同一时间先提交)的任务放在前面
* ScheduledThreadPoolExecutor执行周期任务的步骤
以下是针对同一个工作线程来说
    1. 从DelayQueue中获取到周期任务(ScheduledFutureTask)
        * DelayQueue.take()来获取周期任务
            * 实现步骤
                1. 获取锁(Lock)
                2. 获取周期任务
                    * 如果优先队列为空 线程在锁的Condition对象上等待
                    * 如果优先队列不为空 则取出头元素比较time与当前时间
                        * 如果time比当前时间晚
                        则让线程在锁的Condition对象上等待到time
                        * 否则取出周期任务
                        因为取走了优先队列的头元素 改变了队列状态
                        检查队列若不为空则唤醒等待在Condition上的线程
                3. 释放锁
            * 源码
                ```java
                public E take() throws InterruptedException {
                    final ReentrantLock lock = this.lock;
                    //加锁
                    lock.lockInterruptibly();
                    try {
                        for (;;) {
                            E first = q.peek();
                            //如果优先队列没有元素则等待在Condition对象上
                            if (first == null)
                                available.await();
                            else {
                            //否则取首元素的time来跟当前时间比较
                            //如果已经到期则拿到任务
                                long delay = first.getDelay(NANOSECONDS);
                                if (delay <= 0)
                                    return q.poll();
                                first = null; // don't retain ref while waiting
                                //如果未到期且有线程在定时等待首元素
                                //则当前线程在Conditon对象上等待
                                if (leader != null)
                                    available.await();
                                else {
                                //否则没有线程在首元素上定时等待
                                //让当前线程定是等待首元素
                                    Thread thisThread = Thread.currentThread();
                                    leader = thisThread;
                                    try {
                                        available.awaitNanos(delay);
                                    } finally {
                                    //等待完毕后清空等待在首元素的线程的记录
                                        if (leader == thisThread)
                                            leader = null;
                                    }
                                }
                            }
                        }
                    } finally {
                        //最后不论是否拿到任务
                        //如果没有线程在首元素上定时等待且队列不空
                        //则唤醒一个线程来获取任务
                        if (leader == null && q.peek() != null)
                            available.signal();
                        lock.unlock();
                    }
                }
                ```
    2. 执行这个周期任务
    3. 修改这个周期任务的time为下次执行的时间
    4. 将这个修改后的周期任务放回到DelayQueue中
        * DelayQueue.add()来放回修改后的任务
            * 实现步骤
                1. 加锁(Lock)
                2. 将任务添加至优先队列
                添加后如果添加的任务是头元素 则说明之前队列为空
                添加任务改变了为空的队列状态
                唤醒等待在Condition对象上的线程
                3. 释放锁
            * 源码
                ```java
                //add直接调用的offer()
                public boolean offer(E e) {
                    final ReentrantLock lock = this.lock;
                    //加锁
                    lock.lock();
                    try {
                        //将任务加入优先队列
                        q.offer(e);
                        //如果加入的元素是首元素 则改变了队列空的状态
                        //唤醒一个等待在Condition对象上的等待获取元素线程
                        if (q.peek() == e) {
                            leader = null;
                            available.signal();
                        }
                        return true;
                    } finally {
                        //解锁
                        lock.unlock();
                    }
                }
                ```
### FutureTask详解
* FutureTask与实现Future接口的类代表异步计算结果
* FutureTask不仅实现了Future接口 还实现了Runnable接口
* FutureTask的三种状态
    1. 未启动
        * 时间
        FutureTask.run()执行前
        * 调用结果
            * get()
            将导致调用线程被阻塞
            * cancel()
            将导致此任务永远不被执行
    2. 已启动
        * 时间
        FutureTask.run()执行过程中
        * 调用结果
            * get()
            将导致调用线程被阻塞
            * cancel(true)
            将尝试以中断执行此任务的线程来停止任务的执行
            * cancel(false)
            不会中断执行任务的线程
    3. 已完成
        * 时间
            * FutureTask.run()执行完后正常结束 
            * 在执行过程中抛出异常而异常结束
            * 通过FutureTask.cancel()被取消
        * 调用结果
            * get()
            将导致调用线程立即返回执行结果或者抛出异常
            * cancel()
            将返回false
#### FutureTask的使用
* FutureTask可以交给Executor执行
或通过ExecutorService.sumbit()返回FutrueTask 再通过get()得到执行结果
也可以单独使用FutureTask
* 使用实例
在并发的情况下让每个任务最多只创建并执行一次
    ```java
    public class FutureTaskTest {
        //线程安全的任务缓存容器
        //存放的为任务名称-任务异步计算结果键值对
        //任务内容为返回任务的名称
        private final Map<String,Future<String>> taskCache=new ConcurrentHashMap<>();
    
        public String executeTask(String taskName) throws ExecutionException, InterruptedException {
            //首先获取到任务的异步计算结果
            Future<String> future=null;
            future=taskCache.get(taskName);
            //如果当前任务没有异步计算结果就创建任务并得到异步计算结果
            if (future==null){
                FutureTask<String> task=new FutureTask<>(new Callable<String>() {
                    @Override
                    public String call() throws Exception {
                        //模仿任务耗时
                        Thread.sleep(1000);
                        return taskName;
                    }
                });
    
                //如果在线程并发下仍然没有此任务的异步计算结果则把新创建的任务的异步计算结果加入到任务缓存中
                future=taskCache.putIfAbsent(taskName,task);
    
                //如果原来的任务异步计算结果仍然为空 则把创建的任务异步计算结果作为任务异步计算结果
                if (future==null){
                    future=task;
                    //执行任务
                    task.run();
                }
            }
    
            //最后所有线程都在此等待其中一个线程执行完任务
            //阻塞在此获取任务结果
            return future.get();
        }
    }
    ```
#### FutureTask的实现
* FutureTask基于AQS实现
内部子类Sync实现了tryAcquireShared(int)与tryReleaseShared(int)
来获取与释放同步状态
* FutureTask.get()的运行机制
    1. 调用同步器的模板方法acquireSharedInterruptly(int)
    它又调用Sync实现的tryAcquireShared(int)来获取同步状态
    如果同步状态为完成状态(RAN)或取消状态(CANCELLE)且执行线程不空
    则成功获取到同步状态
    2. 如果获取同步状态失败则当前线程加入到同步队列等待并被阻塞
    3. 当其他线程执行了cancel()或者run() 则唤醒当前线程
    当前线程再次调用tryAcquireShared()获取到同步状态并唤醒后继线程
    4. 最后返回执行结果或者抛出异常
* FutureTask.run()的运行机制
    1. 通过调用Callable.call()执行携带的任务
    2. 以原子方式(CAS)更新同步状态为完成状态(RAN)
    成功后设置result为Callable对象.call()的返回结果
    并调用同步器的模板方法releaseShared(int)来释放同步状态
    3. releaseShared()会回调Sync的tryReleasedShared(int)来释放同步状态
    (将执行线程设置为null)然后唤醒同步队列中的第一个线程
    4. 调用FutureTask.done() 表示任务执行完成
## Java并发编程实战
### 生产者与消费者模式
在并发编程中使用生产者于消费者模式能解决绝大多数并发问题
* 生产者于消费者模式用于解决生产与消费能力不均衡的问题
* 生产者与消费者不直接通信 而是通过阻塞队列来通信
阻塞队列相当于缓冲区 来给生产者与消费者解耦
* 使用实例
用一个消费者线程来提取邮件 并用一个生产者线程池来下载邮件
    ```java
    class Email{
        public String content;
    
        public Email(String content){
            this.content=content;
        }
    }
    public class EmailDownloader {
        //用于存放提取出的邮件
        //生产者将提取出的邮件放入这个阻塞队列
        //消费者从这个阻塞队列取出邮件并下载到本地
        private LinkedBlockingQueue<Email> emails;
    
        //线程池 用于存放消费者线程
        private ThreadPoolExecutor executor;
    
        public EmailDownloader(){
            emails=new LinkedBlockingQueue<>(20);
            //创建重用线程数为10的线程池 用于消费者线程下载邮件
            executor=new ThreadPoolExecutor(10,10,5,
                    TimeUnit.SECONDS,new LinkedBlockingQueue<>());
        }
    
    
        //提取邮件并下载到本地
        public void extractAndDownload() throws InterruptedException {
            //启动一个生产者线程来提取邮件
            new Thread(new Runnable() {
                @Override
                public void run() {
                        for(int i=0;i<500;i++){
                            try {
                                //模拟提取邮件耗时
                                Thread.sleep(100);
                                emails.add(new Email("email"+i));
                                //提取完成后输出提取了一个信件
                                System.out.println(Thread.currentThread().getName()+" extract a email");
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                }
            }).start();
    
            //当前线程不断从邮件队列中取出邮件给消费者下载
            while (true){
                //从邮件队列中超时获取一个邮件
                Email email=emails.poll(3,TimeUnit.SECONDS);
                //如果超时未获取到则说明已经无邮件可下载 退出循环
                if (email==null)
                    break;
    
                //否则让线程池中的一个消费者线程下载提取出的一个邮件
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            //模拟下载耗时
                            Thread.sleep(500);
                            System.out.println(Thread.currentThread().getName()+" download a email,content is:"+email.content);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                });
    
            }
        }
    
        @Test
        public void test() throws InterruptedException {
            extractAndDownload();
        }
    }
    ```
#### 多生产者和多消费者场景
* 可以使用多个线程生产数据与多个线程消费数据
或是消费者处理完数据后作为生产者将数据放入新的队列交给其他消费者处理
* 使用实例
用一个生产者线程池和一个消费者线程池完成消息的产生和分发
    ```java
    class Message{
        public String content;
    
        public Message(String content){
            this.content=content;
        }
    }
    public class MessageDispatcher {
        //主消息队列 用于分发消息给子队列
        private BlockingQueue<Message> mainQueue;
        //多个子消息队列 用于多个消费者线程使用
        private BlockingQueue<Message>[] subQueues;
    
        //生产者线程池
        private ExecutorService producerExecutor;
        //消费者线程池
        private ExecutorService customerExecutor;
    
        public MessageDispatcher(){
            //采用传递阻塞队列 将消息分发给子队列
            mainQueue=new LinkedTransferQueue<>();
            //三个消息子队列
            subQueues=new BlockingQueue[3];
            for (int i = 0; i <3 ; i++) {
                subQueues[i]=new LinkedBlockingQueue<>();
            }
    
            //初始化线程池
            producerExecutor= Executors.newFixedThreadPool(20);
            customerExecutor= Executors.newFixedThreadPool(10);
        }
    
        public void dispatch(){
            //生产者线程池持续产生消息
            for (int i = 0; i <200 ; i++) {
                int finalI = i;
                producerExecutor.execute(new Runnable() {
                    @Override
                    public void run() {
                        //模拟产生消息耗时
                        try {
                            Thread.sleep(500);
                            mainQueue.offer(new Message("content "+ finalI));
                            System.out.println(Thread.currentThread().getName()+" produce message");
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                });
            }
    
            //消费者线程不断将消息分发到子队列中
            for (int i = 0; i <200 ; i++) {
                customerExecutor.execute(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            //模拟分发耗时
                            Thread.sleep(1000);
                            Message message=mainQueue.poll();
                            subQueues[(int) (System.currentTimeMillis()%subQueues.length)].offer(message);
                            System.out.println(Thread.currentThread().getName()+" dispatch message");
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                });
            }
        }
    
        @Test
        public void test() throws InterruptedException {
            dispatch();
            //让测试线程休眠30秒 让其他线程能充分执行
            Thread.sleep(30000);
            System.out.println("the length of message mainQueue is "+mainQueue.size());
            for (int i = 0; i <subQueues.length ; i++) {
                System.out.println("the length of message subQueue "+(i+1)+" is "+subQueues[i].size());
            }
        }
    }
    ```
#### 线程池与生产消费者模式
* 可以采用线程池来实现多生产者和消费者模式
例如：一个线程池处理生产者任务 一个线程池处理消费者任务
* 使用实例
见上一个使用实例
### 异步任务池
* 异步任务用于在集群环境下有效地调度所有机器的任务
* 主要处理流程
每台机器都有一个任务池(包含多个线程池)
当某个线程将一个任务交给任务池后 任务池将其保存到数据库中
然后某个机器从数据库中获取待执行的任务来执行
* 异步任务的属性
任务名称、下次执行时间、已执行次数、任务类型、优先级以及执行的错误信息
* 异步任务的状态
    1. 创建
    提交给任务池后
    2. 执行中
    从数据库中拿出并执行
    3. 重试
    当执行任务出错时 标记为重试并设置下次执行时间
    4. 挂起
    当前任务依赖于其他任务 接收到消息再执行
    5. 中止
    任务执行失败 停止执行并设置错误消息
    6. 执行完成
    任务执行结束
* 任务隔离
异步任务有不同类型 要使用不同线程池处理不同任务
    * 当任务类型少 建议使用任务类型来隔离
    * 当任务类型多 建议使用任务优先级来隔离
* 重试策略
    * 如果任务对实时性要求高 则重试间隔应该设置得非常短
    * 如果不高 可以采用默认策略：重试间隔次数随重试次数增加
* 注意
异步任务必须无状态
即任务不能在执行的机器上保存数据 例如文件等
这对其他机器来说是不可见的