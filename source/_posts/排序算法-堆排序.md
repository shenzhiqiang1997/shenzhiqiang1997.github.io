---
title: 排序算法-堆排序
date: 2018-09-05 17:39:00
tags: 
    - 算法
    - 排序
categories: 
    - 算法
---
# 堆排序
## 概述
任意节点都要>=其子节点的一个完全二叉树被称为最大堆，任意节点都要<=其子节点的一棵完全二叉树被称为最小堆。
<!-- more -->
## 排序过程
1. 将无序数组构建为一个堆
2. 取出堆顶并将堆中最后一个元素设置为堆顶
3. 以堆顶为起点自下而上地调整结构，使其恢复为堆
4. 重复以上过程直到堆中所有元素被取出  

## 如何实现
以最小堆为例进行分析。  
首先考虑步骤3的实现，广泛的来说即如何调整一个除根节点之外，其他节点都满足堆结构的树成为一个堆。  
将树的根节点与其儿子中最小的进行比较，将最小的儿子与该根节点进行交换，然后再将交换后的节点与交换后的两个儿子进行比较与交换，重复该过程，直到它小于等于两个儿子或者到达堆的最底部为止。  
然后再考虑步骤1的实现，只需要以最末的非叶节点为起点，自下而上，自右向左地调整结构，就能将无序数组构建为堆。  
最后考虑堆排序的具体实现，取出堆顶，之后将最末的元素设置为堆顶，此时除了堆顶，其他部分都满足堆的结构，然后以新的堆顶为起点进行结构调整便可以恢复为堆。然后重复以上过程，将取出的堆顶进行排列就是排序的结构。
## 实现代码
```java
/*  这里是实现的最小堆
    数组中的0号位置不存放数据
    方便访问子节点和父节点
*/
public class HeapSort {
    public void sort(int[] numbers,int n){
        /* 从第一个非叶节点开始自下而上 自右向左地调整每个子树的根节点维护
           使其满足堆的结构 */
        for (int i = n/2; i >= 1; i--) {
            adjust(numbers,i,n);
        }
        /* 堆已经构建好了 */

        /*
            每次将堆顶与堆最末尾的元素交换
            之后再以整棵树的根节点进行规模减一进行调整结构
            最后堆会以逆序的形式存放在原数组中
         */
        for (int i = n; i >= 1 ; i--) {
            /* 将末尾的元素与堆顶交换 */
            numbers[0] = numbers[1];
            numbers[1] = numbers[i];
            numbers[i] = numbers[0];

            /* 以树根为起点进行规模减一的结构调整 */
            adjust(numbers,1,i-1);
        }

    }

    private void adjust(int[] numbers, int root, int n) {
        /* 将当前子树的根节点存放到0位置上 */
        numbers[0] = numbers[root];
        /* 找到左儿子的位置 */
        int k = root * 2;
        /* 当左儿子未超过范围时应当继续调整结构 */
        while (k <= n) {
            /* 当存在右儿子时 找到左右儿子中最小的节点 之后k指向儿子中较小的那个*/
            if (k < n && numbers[k + 1] < numbers[k]) k++;
            /* 因为是自下而上地调整
               如果根节点已经比儿子节点要小
               则说明结构已经调整好了 退出循环
             */
            if (numbers[0] <= numbers[k])
                break;
            /* 否则就将儿子中较小的节点交换上来 */
            numbers[root] = numbers[k];
            /* 继续向下调整 直到初始的根节点找到合适的位置 才完成结构调整 */
            root = k;
            k = root * 2;
        }

        /* 此时已经完成结构调整 只需要将初始的根节点放到已找到的合适的位置 */
        numbers[root] = numbers[0];
    }
}
```  
## 时间复杂度
一共要取出n次堆顶，取出堆顶后每次的结构调整是最坏的情况从堆顶开始一直比较到叶节点，时间复杂度为堆的高度即O(logn)，所以整体的时间复杂度为O(nlogn)。
## 稳定性
考虑以下情况，未排序之前根节点为10，左儿子为10，右儿子为6，如果是最小堆，那么根节点中的10会与右儿子交换，根节点中的10在交换之前是在左儿子中的10的前方的，交换之后变成了左儿子汇总的10的后方，相对位置发生了改变，是不稳定的。