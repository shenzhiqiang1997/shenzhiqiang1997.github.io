---
title: 排序算法-归并排序
date: 2018-09-05 12:35:00
tags: 
    - 算法
    - 排序
categories: 
    - 算法
---
# 归并排序
## 概述
归并排序的思想是将数组不断二分进行归并排序，当较小的部分有序后再将二分的两个有序的部分合并为一个完整的有序数组。
<!-- more -->
## 如何实现
首先要将要排序的数组拷贝到一个辅助数组中，目的是在辅助数组中归并排序，在合并完成后再将合并后的部分更新到原数组中。  
之后，在数组可再分的情况下，从中心分为左右两个部分，递归地对前半部分和右半部分进行排序，这之后前半部分和右半部分已经有序，再对两个有序的部分进行合并。  
合并的过程就是用两个指针在两个分数组上移动，不断比较指针所指的元素，总是将两个分数组上当前最小的元素按序放入辅助数组中，之后向后移动较小元素所在数组的指针，直到有一个指针超过分数组的尾部，则另一分数组的剩余元素都要大于该分数组中元素，只需要将其衔接到合并的后续位置即可。  
最后再将辅助数组中合并后的部分更新到原数组中。
不断重复以上过程直到数组不可再分后结束递归并逐渐被合并为一个整体就完成了数组的排序。
## 实现代码
```java
public class MergeSort {
    public void sort(int[] numbers){
        /* 辅助数组 用于排序与合并操作 等合并后再将合并结果写回原数组*/
        int[] temp = new int[numbers.length];
        System.arraycopy(numbers,0,temp,0,numbers.length);

        /* 对数组整体进行归并排序 */
        sort(numbers,temp,0,numbers.length-1);
    }

    private void sort(int[] numbers, int[] temp, int start, int end) {
        /* 如果start<end 说明可以继续二分 否则已经划分到单个元素 无法再划分*/
        if (start<end){
            int mid = (start+end)/2;
            /* 对前半部分进行归并排序 */
            sort(numbers,temp,start,mid);
            /* 对后半部分进行归并排序*/
            sort(numbers,temp,mid+1,end);
            /* 此时前半部分和后半部分已经分别有序排列
            只需要将前半部分和后半部分合并后更新到原数组 */
            merge(numbers,temp,start,mid,end);
        }
    }

    private void merge(int[] numbers, int[] temp, int start, int mid, int end) {
        int i = start,j = mid+1,index = start;
        /* 从前半部分和右半部分的第一个元素开始比较
        每次把两个部分中较小的元素按顺序存放到辅助数组中
        之后再移动指针继续比较 直到其中一个指针超过所在部分的尾部*/
        while (i <= mid && j <= end){
            if (numbers[i]<numbers[j])
                temp[index++] = numbers[i++];
            else
                temp[index++] = numbers[j++];
        }

        /*
           当一个部分的指针超过尾部
           说明另一部分的剩余部分都要比该部分的元素要大
           将这部分直接衔接到辅助数组的后续位置
        */

        while (i <= mid)
            temp[index++] = numbers[i++];
        while (j <= end)
            temp[index++] = numbers[j++];

        /* 将合并后的部分更新到原数组 */
        for (int k = start; k <= end; k++)
            numbers[k] = temp[k];

    }
}
```  
## 时间复杂度
采用了分而治之的方法，二分的次数即归并的次数为logn,每次合并的时间复杂度为O(n)，所以整体时间复杂度为O(nlogn)。
## 空间复杂度
使用了一个与原数组相同大小的辅助数组进行排序与合并工作，空间复杂度为O(n)
## 稳定性
由于合并的时候总是将两个分数组中较小的元素放在合并后数组的前面部分，并且相等元素总是前半部分的元素放在前面，所以是稳定的。