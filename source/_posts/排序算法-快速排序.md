---
title: 排序算法-快速排序
date: 2018-09-05 12:35:00
tags: 
    - 算法
    - 排序
categories: 
    - 算法
---
# 快速排序
## 概述
快速排序的思想是选择一个划分元，用该划分元来调整数组，使得左侧的元素<=划分元，右侧的元素>=划分元，再分别递归地对左侧和右侧的数组进行快速排序，最终使得整个数组有序。
<!-- more -->
## 如何实现
首先是在数组可以继续划分的前提下，选择数组一个元素作为划分元来调整数组中元素的位置。  
这个过程一般采用两个指针low和high分别指向数组的第一个元素和最后一个元素，在low<high的前提下，数组可以继续调整。  
如何进行调整呢，默认选择low所在的元素作为划分元，这时low的位置空了出来，从high位置开始向前考虑，如果这些元素>=划分元则它们处于正确的位置，在划分元的右侧；如果有元素<=划分元，则处于错误的位置，需要将它们交换到左侧即之前空出来的low的位置，同时high的位置空了出来并且low位置及其之前的元素都<=划分元，那么将low+1。  
然后再从low位置开始向后考虑，如果这些元素<=划分元则它们处于正确的位置，在划分元的左侧；如果有元素>=划分元，则处于错误的位置，需要将它们交换到右侧即之前空出来的high的位置，同时low位置空了出来并且high位置及其之后的元素都>=划分元，那么将high-1。  
之后循环以上过程，直到low不再<high，即low==high，则调整完毕，此时low位置的左侧的元素都<=划分元，low位置的右侧元素都>=划分元，则将划分元放置到low所在的位置，并将划分元的位置记录下来。  
之后根据划分元的位置，分别递归地对左侧和右侧进行快速排序，最终得到有序的数组。
## 实现代码
```java
public class QuickSort {
    public void sort(int[] numbers){
        /* 对数组进行快速排序 */
        quickSort(numbers,0,numbers.length-1);
    }

    private void quickSort(int[] numbers,int low,int high){
        /* 如果low<high 说明数组可以继续划分数组进行递归快排 */
        if (low<high){
            /*
            按照划分元
            将比划分元小的元素放到左侧 比划分元大的元素放到右侧 并返回划分元的位置
            即进行切分
             */
            int idx = partition(numbers,low,high);
            /* 递归的对左侧进行快速排序 */
            quickSort(numbers,low,idx-1);
            /* 递归地对右侧进行快速排序 */
            quickSort(numbers,idx+1,high);
        }
    }

    private int partition(int[] numbers, int low, int high) {
        /* 默认采用low所在的元素作为划分元 此时low的位置空了出来*/
        int partitionElement = numbers[low];
        /* 当low<high说明元素位置还可以继续调整 */
        while (low<high){
            /* 找到右侧比划分元小的元素 */
            while (low<high && numbers[high]>=partitionElement)
                high--;
            /* 将比划分元小的元素交换到左侧的空位low 此时位置high空了出来 */
            if (low<high)
                numbers[low++] = numbers[high];

            /* 找到左侧比划分元大的元素 */
            while (low<high && numbers[low]<=partitionElement)
                low++;
            /* 将比划分元大的元素交换到右侧的空位high 此时位置low 空了出来 */
            if (low<high)
                numbers[high--] = numbers[low];
        }

        /* 最后low == high low所在的位置就是划分元的位置 */
        numbers[low] = partitionElement;
        return low;
    }
}
```
# 时间复杂度
从直觉上来分析，划分之后递归地对两部分进行快速排序，平均要O(logn)次。每次快速排序要遍历并操作一次数组，时间复杂度为O(n)，总体平均时间复杂度为O(nlogn)。实际中时间复杂度会根据划分元的选择和数组是否有序变化。
# 稳定性
由于在利用划分元调整数组时可能将右侧的一个元素调整到左侧来或者将一个左侧的元素调整到右侧来，元素的跳跃性很强，所以相等元素的相对位置是有可能发生改变的,是不稳定的。


