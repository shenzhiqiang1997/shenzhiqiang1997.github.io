---
title: 索引优化-覆盖索引和最左前缀原则
date: 2018-08-22 17:51:00
updated: 2018-11-07 15:23:00
categories:
    - MySQL
tags: 
    - MySQL
    - 索引
    - 数据库
---
# 覆盖索引
覆盖索引就是可以覆盖要查询所需要的所有列的索引。  
其中所需要的列是指SELECT,WHERE,GROUP BY,ORDER BY,JOIN所需的列  
<!-- more -->
假设有下面一个表
```sql
CREATE TABLE `user`(
    `username` VARCHAR(12) PRIMARY KEY,
    `password` VARCHAR(20), 
    `name` CHAR(12)
)
```  
考虑下面一个查询
```sql
EXPLAIN SELECT password FROM user WHERE name = '张三';
```  
那么这个查询所需要的列有password和name，而表中并没有覆盖这两个列的索引。  
倘若把这个表的创建语句改动一下呢  
```sql
CREATE TABLE `user`(
    `username` VARCHAR(12) PRIMARY KEY,
    `password` VARCHAR(20), 
    `name` CHAR(12),
    INDEX idx_password(password)
)
```  
分析查询，尽管现在有一个覆盖了password的索引，但仍然没有使得查询使用这个索引。  
```sql
+----+-------------+-------+------------+------+---------------+------+
| id | select_type | table | partitions | type | possible_keys | key  | 
+----+-------------+-------+------------+------+---------------+------+
|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | 
+----+-------------+-------+------------+------+---------------+------+
+---------+------+------+----------+-------------+
| key_len | ref  | rows | filtered | Extra       |
+---------+------+------+----------+-------------+
| NULL    | NULL |    1 |   100.00 | Using where |
+---------+------+------+----------+-------------+
```  
我们尝试着添加一个name和password的复合索引，再次分析该查询，结果不同了。  
```sql
 ALTER TABLE user ADD INDEX idx_name_password (name,password);
```  
```sql
+----+-------------+-------+------------+-------+---------------+
| id | select_type | table | partitions | type  | possible_keys | 
+----+-------------+-------+------------+-------+---------------+
|  1 | SIMPLE      | user  | NULL       | index | NULL          | 
+----+-------------+-------+------------+-------+---------------+
+-------------------+---------+------+------+----------+-------------+
| key               | key_len | ref  | rows | filtered | Extra       |
+-------------------+---------+------+------+----------+-------------+
| idx_name_password | 100     | NULL |    1 |   100.00 | Using index |
+-------------------+---------+------+------+----------+-------------+
```  
我们可以看到这次查询使用了我们添加的复合索引，这个索引就是覆盖索引，它覆盖了要查询的nam  e和password列。  
## 好处  
覆盖索引尤其对MySQL中的InnoDB引擎有好处，在辅助索引中其实叶节点是存储了索引列的数据，如果辅助索引成为覆盖索引，那么就能保证在查询辅助索引时就获取到要查询的列，而不用二次查询主索引并访问数据行了。
# 最左前缀原则
最左前缀原则其实是索引匹配原则，它适用于B+Tree索引。  
举一个例子  
```sql
CREATE TABLE `user`(
    `username` VARCHAR(12) PRIMARY KEY,
    `password` VARCHAR(20), 
    `name` CHAR(12),
    `address` VARCHAR(50),
    INDEX idx(password,name,address)
)
```  
那只有以下三种情况才会进行索引匹配  
```sql
SELECT * FROM user WHERE password = '1';
SELECT * FROM user WHERE password = '1' AND name ='2';
SELECT * FROM user WHERE password = '1' AND name ='2' AND address = '3';
```  
## 原理
假设有一个索引(a,b,c)，MySQL在创建索引时，索引将会先按照a排序，然后按照b排序，最后按照c排序。  
假设有下面一组索引，只考虑B+树的根节点，它们应该是从左到右排列的。
```
1 1 1|1 1 2|1 2 1|1 2 2|2 1 1|2 1 2|2 2 1|2 2 2
```  
* 单独从a的角度来看，是有序的，可以通过二分法查找到对应的索引。分别单独从b,c的的角度来看，是无序的，无法通过二分法来查找到对应的索引，除非将全部索引扫描一遍。  
* 假如能够满足最左前缀原则，就能先根据a利用二分法确定一部分索引的范围，比如a=1，就能确认要找的索引范围为前四个。  
此时在这个范围内部来看b也有序了，然后就可以再根据b利用二分法确定一部分索引的范围，比如b=2，就能确认要找到的索引范围为第三个和第四个。  
此时在这个范围内部来看c也有序了，然后就可以再根据c利用二分法确定要找的索引，比如c=1，就能找到我们要的第三个索引了。  
* 总结：MySQL按照a,b,c的顺序依次排序索引，当满足最左前缀原则时，这些索引是相对有序的，从而可以按照二分查找不断缩小待选索引的范围，从而最终查找到要找的索引。一旦打破最左前缀原则，目标索引是相对无序的，无法利用二分查找来缩小待选索引范围，只能通过扫描所有索引的方式，比全表扫描效率还低，MySQL就会避免这样的情况发生，不走索引，直接进行全表扫描。


