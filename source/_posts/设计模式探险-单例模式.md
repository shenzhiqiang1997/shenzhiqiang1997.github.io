---
title: 设计模式探险-单例模式
date: 2018-04-09 18:59:55
tags: 
    - 设计模式
    - Java
categories: 
    - 设计模式
---
# 单例模式
什么是单例模式：  
单例模式就是一个类中只有一个该类的实例，外界只能通过该类提供的接口来获取这个实例，并且每次获取到的实例都是该同一个实例。  
  
如何实现：  
1.构造方法私有化，不允许外界通过构造方法来创建实例。  
2.将单例设置为静态变量，来表示其属于类的这一含义。  
3.暴露一个静态接口让外界通过类访问该接口来获取单例。
<!-- more -->
# 饿汉式
* lazy-init：否
* 线程安全：是
* 实现代码：  
  ```java
    public class Singleton {
        private static Singleton instance = new Singleton();
    
        private Singleton(){}
    
        public static Singleton getInstance(){
            return instance;
        }
    }
  ```
* 在类加载的时候实例化一次 线程安全  
  但牺牲了懒加载的能力 无法节省资源
# 懒汉式-非线程安全
* lazy-init： 是
* 线程安全：否
* 实现代码：
    ```java
    public class Singleton {
        private static Singleton instance;
    
        private Singleton(){}
    
        public static Singleton getInstance(){
            if (instance == null)
                instance=new Singleton();
            
            return instance;
        }
    }
    ```
* 当未实例化时才创建实例 实现了懒加载  
  但当多线程环境下可能创建多个实例 线程不安全
# 懒汉式-线程安全
* lazy-init：是
* 线程安全：是
* 实现代码：
    ```java
    public class Singleton {
        private static Singleton instance;
    
        private Singleton(){}
    
        public synchronized static Singleton getInstance(){
            if (instance == null)
                instance=new Singleton();
    
            return instance;
        }
    }
    ```
* 在非线程安全的懒汉式基础上将获取实例的方法改为同步方法  
  虽然保证了线程安全 但是导致在同一时刻只能有一个线程进入方法  
  其他想进入该方法的线程将在方法入口处等待 效率很低
# 双重检查锁方式
* lazy-init：是
* 线程安全：是
* 实现代码：
    ```java
    public class Singleton {
        private volatile static Singleton instance;
    
        private Singleton(){}
    
        public static Singleton getInstance(){
            if (instance == null){
                synchronized (Singleton.class){
                    if (instance == null)
                        instance = new Singleton();
                }
            }
    
            return instance;
        }
    }
    ```
* 在线程安全的懒汉式基础上继续优化  
  在实例未创建时对整个类进行加锁 并创建实例  
  这种实现方式只在第一次创建实例时进行加锁  
  相比线程安全的懒汉式效率更高
* 第二次实例检查的作用是在先获取锁的线程创建完实例后  
  之前争夺锁的进程在获取锁后再次企图创建实例时检查实例是否已经创建  
  从而避免实例的多次创建  
    
* 此外 volatile的作用是  
  instance = new Singleton();  
  分为三步  1.分配内存空间 2.初始化对象 3.引用指向分配的内存地址  
  由于JVM中存在指令重排序 这条语句的顺序可能会变成 1->3->2  
  在单线程的情况下不会有问题  
  但在多线程的情况下会导致其他线程返回并使用未初始化的对象 导致错误  
  而volatile变量通过插入内存屏障来禁止重排序 来保证这一过程的正常运行
# 内部静态类方式
* lazy-init：是
* 线程安全：是
* 实现代码：
    ```java
    public class Singleton {
        private Singleton(){}
    
        public static Singleton getInstance(){
            return SingletonHolder.instance;
        }
    
        private static class SingletonHolder{
            private static Singleton instance = new Singleton();
        }
    }
    ```
* 在第一次调用getInstance()时  
会加载SingletonHolder类并实例化实例 实现了懒加载  
类加载和初始化的过程由JVM进行同步处理 是线程安全的  
这也就保证了第一次实例化时的线程安全性
# 枚举方式
* lazy-init：否
* 线程安全：是
* 实现代码：
    ```java
    public enum Singleton {
        INSTANCE;
    }
    ```
* 反编译结果：
    ```java
    public abstract class Singleton extends Enum
    {
    
        private Singleton(String s, int i)
        {
            super(s, i);
        }
    
        public static Singleton[] values()
        {
            Singleton asingleton[];
            int i;
            Singleton asingleton1[];
            System.arraycopy(asingleton = ENUM$VALUES, 0, asingleton1 = new Singleton[i = asingleton.length], 0, i);
            return asingleton1;
        }
    
        public static Singleton valueOf(String s)
        {
            return (Singleton)Enum.valueOf(singleton/Singleton, s);
        }
    
        Singleton(String s, int i, Singleton singleton)
        {
            this(s, i);
        }
    
        public static final Singleton INSTANCE;
        private static final Singleton ENUM$VALUES[];
    
        static 
        {
            INSTANCE = new Singleton("INSTANCE", 0) {};
            ENUM$VALUES = (new Singleton[] {INSTANCE});
        }
    }
    ```
* 这种方式有三个优点
    1. 线程安全  
    可以看出是在static部分进行实例化  
    在类加载和初始化的时候由JVM进行同步处理  
    保证创建实例的线程安全性
    2. 实现序列化后仍然可以保证单例  
    之前所说的其他方式在实现了序列化接口之后单例都会被破坏  
    由于从序列化文件中读取对象时调用readObject()会创建新实例  
    而枚举类则默认实现了readResolve()  
    来返回原来的实例而不是创建新的实例
    3. 防止反射攻击  
    由于枚举类型继承Enum类生成的类是抽象类  
    所以无法通过反射来实例化
    ```java
    public abstract class Singleton extends Enum{...}
    ```  
* 当然他唯一的缺点就是不能懒加载