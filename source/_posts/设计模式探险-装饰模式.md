---
title: 设计模式探险-装饰模式
date: 2018-08-30 11:00:00
tags: 
    - 设计模式
    - Java
categories: 
    - 设计模式
---
# 装饰模式
## 什么是装饰模式
装饰类以包装的形式动态地扩展一个类的功能，但不修改类的结构。
<!-- more -->
## 实现方式
装饰类和被装饰类实现相同的接口，装饰类引用被装饰类对象，并在被装饰对象基础上增加新功能。
## 实现代码
```java
/* 使用奶茶添加配料的场景 */

public interface Drink {
    double cost();
}

/* 被装饰类 */
public class Tea implements Drink {
    @Override
    public double cost() {
        return 1;
    }
}

/* 装饰类 */
public abstract class CondimentDecorator implements Drink{
    protected Drink drink;

    public CondimentDecorator(Drink drink){
        this.drink = drink;
    }
}

/* 具体装饰类 */
public class MilkDecorator extends CondimentDecorator {

    public MilkDecorator(Drink drink){
        super(drink);
    }

    @Override
    public double cost() {
        return drink.cost()+1;
    }
}

/* 具体装饰类 */
public class PearlDecorator extends CondimentDecorator{
    public PearlDecorator(Drink drink){
        super(drink);
    }

    @Override
    public double cost() {
        return drink.cost()+1;
    }
}

public class DecoratorTest {
    public static void main(String[] args) {
        Drink drink = new Tea();
        drink = new MilkDecorator(drink);
        drink = new PearlDecorator(drink);
        System.out.println(drink.cost());
    }
}

```
## 使用场景
当通过继承来扩展一个类的功能，由于扩展频繁导致子类的代码膨胀时可以考虑使用装饰模式，优点在于满足开放-封闭原则，易于扩展。
## 与代理模式的区别
相信大家也发现了，装饰模式和代理模式的写法极其相似，它们之间的区别在于目的不同
* 装饰模式是为了动态扩展类的功能
* 代理模式是为了对被代理对象进行控制