---
title: 频繁FullGC问题
date: 2018-10-25 01:12:00
tags: 
    - JVM
    - GC
categories:
    - JVM
---
# 什么是频繁FullGC
这里的FullGC即会导致用户线程停顿的GC，它的频繁发生将引发服务器无法提供服务。
<!--more-->
# 引发频繁FullGC的原因
1. 老年代空间不足，往往是长期存活的大对象导致，或长期存活且无法回收的对象导致的内存泄露。
2. 永久代空间不足，往往是大量使用动态字节码和类加载的结果。
3. 在MinorGC时新生代的survivor不足以拷贝新生代存活的对象，同时老年代不允许分配担保或者分配担保失败。
4. 当老年代使用CMS垃圾收集器时，如果老年代在GC时剩余的空间不足以进行CMS GC，或者剩余的空间不足以在并发清除阶段存放浮动垃圾而抛出Concurrent Mode Failure时。  

# 步骤
1. 首先用jmap -dump pid生成堆转储快照
2. 利用jvisualvm分析堆中实例情况查看是否存在内存泄露的情况
3. 如果不是，则继续查看GC日志，对每次Full GC进行关联分析。
4. 如果FullGC后老年代的内存没有什么变化则是原因1
5. 借助jstat -class pid 来查看类的装载和卸载情况，如果有大量类加载则是原因2。
6. 原因3和4可以通过日志中FullGC（promotion failured）和（concurrent mode failure识别出来）。
7. 其他原因只能通过分析GC日志慢慢排查了。
# 如何解决
1. 对于原因1，增大大对象进入老年代的阈值，以及增加长期存活的对象进入老年代的年龄阈值，保证对象朝生夕死，避免创建大对象。
2. 对于原因2，可以增大永久代的容量。
3. 对于原因3，可以增大新生代的容量，尽量开启分配担保。
4. 对于原因4，考虑通过使用其他垃圾收集器避免，例如G1收集器。